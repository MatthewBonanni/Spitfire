%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{Spitfire Documentation}
\date{Jul 15, 2019}
\release{1.0}
\author{Mike Hansen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstyleemphasis{This is all under construction at the moment!}


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}

\section{Objectives \& Access}
\label{\detokenize{introduction:objectives-access}}
Spitfire is a Python/C++ code for scientific computing that has several objectives:
\begin{itemize}
\item {} 
Solve combustion problems with complex chemical kinetics, namely homogeneous reactors and non-premixed flamelets, both steady and unsteady, with advanced time integration and continuation techniques.

\item {} 
Design and rapidly prototype nonlinear solvers and time integration techniques for ordinary and partial differential equations.

\end{itemize}

Spitfire is hosted on \sphinxhref{http://gitlab.multiscale.utah.edu/common/spitfire.git}{GitLab} by the \sphinxhref{https://multiscale.utah.edu/}{Multiscale Simulation Group} at the University of Utah.


\section{Applications}
\label{\detokenize{introduction:applications}}
Spitfire utilizes a general abstraction of time integration appropriate for a range of integration techniques, nonlinear solvers, and linear solvers.
Design of this solver stack is crucial to efficient solution of reacting flow problems with complex chemistry
and the exploration of these algorithms and study of combustion chemistry was Spitfire’s original purpose.
Spitfire combines Python with a C++ code called Griffon in addition to NumPy, SciPy, and Cython to attain the convenience and extensibility of Python and the performance of C/C++.
Python drives processes at an abstract level while either the Griffon code contained in Spitfire or NumPy- and SciPy-wrapped C/Fortran routines are used in performance critical operations.
Spitfire has been used by researchers at the University of Utah and Sandia National Laboratories for a number of applications:
\begin{itemize}
\item {} 
study chemical explosive modes and low-temperature oxidation pathways of complex fuels in non-premixed systems

\item {} 
study the formulation of state vectors and analytical Jacobian matrices for combustion simulation

\item {} 
construct steady adiabatic and nonadiabatic flamelet libraries for simulation of single- and multi-phase combustion

\item {} 
perform fundamental studies of combustion in the MILD regime

\item {} 
generate homogeneous reactor, non-premixed flamelet, and general reaction-diffusion datasets for the training of low-dimensional surrogate models of complex chemical models

\item {} 
investigate the design of specialized embedded pairs of explicit Runge-Kutta methods and advanced adaptive time stepping techniques

\end{itemize}


\chapter{Time Integration}
\label{\detokenize{timeintegration:time-integration}}\label{\detokenize{timeintegration::doc}}

\section{Methods for First-Order Ordinary Differential Equations}
\label{\detokenize{timeintegration:methods-for-first-order-ordinary-differential-equations}}
Spitfire can solve general differential equations (DEs) that can be written in explicit ordinary differential equation (ODE) form,
\begin{equation}\label{equation:timeintegration:general_explicit_ode}
\begin{split}\frac{\partial \boldsymbol{q}}{\partial t} = \boldsymbol{r}(t, \boldsymbol{q}),\end{split}
\end{equation}
where \(\boldsymbol{q}=[q_1,q_2,\ldots]\) is the vector of state variables
and \(\boldsymbol{r}=[r_1,r_2,\ldots]\) is the vector of right-hand side functions.
Many systems of scientific and engineering interest fit into this form,
either as ODEs derived naturally as (\ref{equation:timeintegration:general_explicit_ode}) or as
partial differential equations (PDEs) in semi-discrete form (after spatial, but not temporal, discretization).
Spitfire does not currently support implicit differential equations or differential algebraic equation (DAE) systems
represented generally as \(\mathrm{M}\dot{\boldsymbol{q}}=\boldsymbol{r}(t,\boldsymbol{q})\) for a possibly singular matrix \(\mathrm{M}\).

Spitfire provides a number of explicit and implicit numerical methods of solving DE systems in the form of (\ref{equation:timeintegration:general_explicit_ode}).
All of these methods may be classified as one-step Runge-Kutta methods.
Spitfire does not yet support multi-step methods such as BDF or Adams methods, or general linear methods.
Additionally Spitfire’s abstraction does not support fully-implicit Runge-Kutta methods (singly-diagonally implicit \sphinxtitleref{is} supported).
Finally Spitfire does not (yet!) support implicit-explicit methods such as additive Runge-Kutta or operator splitting techniques.

The explicit methods provided are:
\begin{itemize}
\item {} 
Forward Euler: \sphinxcode{\sphinxupquote{ForwardEuler}}

\item {} 
Midpoint method: \sphinxcode{\sphinxupquote{ExplicitRungeKutta2Midpoint}}

\item {} 
Trapezoidal method: \sphinxcode{\sphinxupquote{ExplicitRungeKutta2Trapezoid}}

\item {} 
Ralston’s two-stage method: \sphinxcode{\sphinxupquote{ExplicitRungeKutta2Ralston}}

\item {} 
Heun’s three-stage method: \sphinxcode{\sphinxupquote{ExplicitRungeKutta3Kutta}}

\item {} 
The ‘classical’ RK4 method: \sphinxcode{\sphinxupquote{ExplicitRungeKutta4Classical}}

\item {} 
The Cash-Karp order 4 method: \sphinxcode{\sphinxupquote{AdaptiveERK54CashKarp}}

\item {} 
A general-purpose explicit RK method that can use any explicit Butcher table provided by the user: \sphinxcode{\sphinxupquote{GeneralAdaptiveExplicitRungeKutta}}

\end{itemize}

Implicit methods that come with Spitfire are:
\begin{itemize}
\item {} 
Backward Euler (BDF1): \sphinxcode{\sphinxupquote{BackwardEuler}}

\item {} 
Crank-Nicolson (implicit Trapezoidal): \sphinxcode{\sphinxupquote{CrankNicolson}}

\item {} 
Midpoint method: \sphinxcode{\sphinxupquote{ImplicitMidpoint}}

\item {} 
Two-stage, L-stable, order 2 method: \sphinxcode{\sphinxupquote{SDIRK22}}

\item {} 
Six-stage, L-stable, order 4 method with stage order two: \sphinxcode{\sphinxupquote{ESDIRK64}}

\end{itemize}

Spitfire provides the above ODE methods ‘out of the box’ and also facilitates the use of additional methods defined by the user.
In addition to the above general-purpose methods,
Spitfire can do error-based adaptive time-stepping with the following methods:
\begin{itemize}
\item {} 
explicit: Euler-Trapezoidal order 2 method: \sphinxcode{\sphinxupquote{AdaptiveERK21HeunEuler}}

\item {} 
explicit: Cash-Karp order 4 method: \sphinxcode{\sphinxupquote{AdaptiveERK54CashKarp}}

\item {} 
implicit: backward Euler: \sphinxcode{\sphinxupquote{BackwardEulerWithError}}

\item {} 
implicit: six-stage, L-stable, order 4 method: \sphinxcode{\sphinxupquote{ESDIRK64}}

\end{itemize}

With the time-steppers listed above, Spitfire provides several means of driving a simulation in time.
All simulations, whether with explicit or implicit methods, with a constant or adaptive time step, are driven by Spitfire’s \sphinxcode{\sphinxupquote{Governor}} class.
The governor manages the logging of information and in-situ post-processing of user data as the simulation proceeds.
It also manages the evaluation of the Jacobian/preconditioning matrix used in implicit methods, depending upon performance
of nonlinear and linear solvers in each implicit time step.


\section{Spitfire’s Abstraction of the Solver Stack}
\label{\detokenize{timeintegration:spitfire-s-abstraction-of-the-solver-stack}}
When ODEs such as (\ref{equation:timeintegration:general_explicit_ode}) are solved with implicit time integration methods, a nonlinear system of equations must be solved at each time step.
The nonlinear system can be written in terms of a nonlinear operator \(\boldsymbol{\mathcal{N}}\),
\begin{equation}\label{equation:timeintegration:eqn: simple nlin}
\begin{split}\boldsymbol{\mathcal{N}}(\boldsymbol{q}) = \boldsymbol{0}.\end{split}
\end{equation}
A corresponding approximate linear operator \(\widetilde{\mathrm{A}}\) is required in solving an exact linear problem required by the nonlinear problem,
\begin{equation}\label{equation:timeintegration:eqn: simple lin}
\begin{split}\widetilde{\mathrm{A}} = \bar{p}\widetilde{\boldsymbol{\mathcal{N}}_{\boldsymbol{q}}} - \mathcal{I} \quad \rightarrow \quad \mathrm{solving}\, \left[\bar{p}\boldsymbol{\mathcal{N}}_{\boldsymbol{q}} - \mathrm{I}\right]\boldsymbol{x}=\boldsymbol{b},\end{split}
\end{equation}
where the prefactor \(\bar{p}=ph\) consists of the temporal discretization coefficient \(p\) and time step size \(h\), the identity operator \(\mathcal{I}\), and identity matrix \(\mathrm{I}\), and the \(\widetilde{\boldsymbol{\mathcal{N}}_{\boldsymbol{q}}}\) operator, an approximation of the Jacobian matrix \(\boldsymbol{\mathcal{N}}_{\boldsymbol{q}}\).
Nonlinear solution procedures typically require the repeated action of the inverse of the \(\mathrm{A}\) operator, which can often be optimized by breaking it up into a costly setup phase (\sphinxstyleemphasis{e.g.}, factorization, preconditioner computation) and cheaper solve phase (\sphinxstyleemphasis{e.g.}, back-solution after factorization) so that the setup is called once per solve while setup is called many times.
The linear problem is a subset of the nonlinear problem, which itself is a subset of each single time step (\(t^n\to t^{n+1}\)), which is a subset of a time integration loop with possibly adaptive time stepping (varying \(h\) in time).
These five pieces form the backbone of time integration with implicit methods.
In Spitfire these are viewed as the \sphinxcode{\sphinxupquote{Governor}} (time loop), \sphinxcode{\sphinxupquote{StepController}} (\(h\) adaptation), \sphinxcode{\sphinxupquote{TimeStepper}} (single step method), \sphinxcode{\sphinxupquote{NonlinearSolver}} (solve \(\boldsymbol{\mathcal{N}}(\boldsymbol{q}) = \boldsymbol{0}\)), and finally the \sphinxcode{\sphinxupquote{setup}} and \sphinxcode{\sphinxupquote{solve}} procedures for the linear solve (build the approximate linear operator’s inverse and repeatedly apply it, respectively).


\subsection{Using Explicit Methods}
\label{\detokenize{timeintegration:using-explicit-methods}}
Note that when explicit methods are used to solve (\ref{equation:timeintegration:general_explicit_ode}), things are simplified dramatically because only the \sphinxcode{\sphinxupquote{Governor}}, \sphinxcode{\sphinxupquote{StepController}}, and \sphinxcode{\sphinxupquote{TimeStepper}} behavior is needed.
The use of explicit methods is demonstrated by several scripts in the \sphinxtitleref{demo/time\_integration} folder.
For example, the \sphinxtitleref{ballistics.py} (and jupyter notebook version \sphinxtitleref{ballistics-demo.ipynb}), \sphinxtitleref{chemistry-abc.py}, \sphinxtitleref{ecology.py}, and \sphinxtitleref{exponential\_decay.py} scripts use explicit methods to solve various specific cases of (\ref{equation:timeintegration:general_explicit_ode}).
Using Spitfire is quite simple here, as the use of the governor simply requires the specification of a termination criterion:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{governor} \PYG{o}{=} \PYG{n}{Governor}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{governor}\PYG{o}{.}\PYG{n}{termination\PYGZus{}criteria} \PYG{o}{=} \PYG{n}{FinalTime}\PYG{p}{(}\PYG{n}{final\PYGZus{}time}\PYG{p}{)}
\end{sphinxVerbatim}

and then the call to the integration method, which is given a right-hand side function as in (\ref{equation:timeintegration:general_explicit_ode}),
an initial condition, a step controller (or if the \(h\) is constant, the value of \(h\)),
and an instance of the \sphinxcode{\sphinxupquote{TimeStepper}} method to use (this example is from \sphinxtitleref{chemistry-abc.py}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{governor}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{right\PYGZus{}hand\PYGZus{}side}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{right\PYGZus{}hand\PYGZus{}side}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{k\PYGZus{}ab}\PYG{p}{,} \PYG{n}{k\PYGZus{}bc}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{initial\PYGZus{}condition}\PYG{o}{=}\PYG{n}{c0}\PYG{p}{,}
                   \PYG{n}{controller}\PYG{o}{=}\PYG{n}{time\PYGZus{}step\PYGZus{}size}\PYG{p}{,}
                   \PYG{n}{method}\PYG{o}{=}\PYG{n}{ExplicitRungeKutta4Classical}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

In order to save data from the simulation, we make a container and provide its \sphinxcode{\sphinxupquote{save\_data}} method to the governor before calling \sphinxcode{\sphinxupquote{integrate}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{SaveAllDataToList}\PYG{p}{(}\PYG{n}{initial\PYGZus{}solution}\PYG{o}{=}\PYG{n}{c0}\PYG{p}{)}
\PYG{n}{governor}\PYG{o}{.}\PYG{n}{custom\PYGZus{}post\PYGZus{}process\PYGZus{}step} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{save\PYGZus{}data}
\end{sphinxVerbatim}

This lets us obtain the solution times and values as follows, for instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{t\PYGZus{}list}
\PYG{n}{q0} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{solution\PYGZus{}list}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

To use an adaptive time stepping approach based on temporal error control, one can build a \sphinxcode{\sphinxupquote{PIController}} instance and
use a method such as \sphinxcode{\sphinxupquote{AdaptiveERK54CashKarp}}.
The corresponding integration call would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{governor}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{right\PYGZus{}hand\PYGZus{}side}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{right\PYGZus{}hand\PYGZus{}side}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{k\PYGZus{}ab}\PYG{p}{,} \PYG{n}{k\PYGZus{}bc}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{initial\PYGZus{}condition}\PYG{o}{=}\PYG{n}{c0}\PYG{p}{,}
                   \PYG{n}{controller}\PYG{o}{=}\PYG{n}{PIController}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{method}\PYG{o}{=}\PYG{n}{AdaptiveERK54CashKarp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

As a final note, many of the instances we’ve built for the step controller and time steppers can be built with
optional parameters (\sphinxstyleemphasis{e.g.} the desired target error for the step controller, or the first time step).
In many cases default values are mostly acceptable.
See the module documentation to learn about available parameters.


\subsection{Using Implicit Methods}
\label{\detokenize{timeintegration:using-implicit-methods}}
Implicit methods may actually be used nearly as easily as explicit methods in simple cases.
In the \sphinxtitleref{exponential\_decay.py} script, the Backward Euler method is used and its integrate call is quite simple:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{governor}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{right\PYGZus{}hand\PYGZus{}side}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{:} \PYG{n}{right\PYGZus{}hand\PYGZus{}side}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{initial\PYGZus{}condition}\PYG{o}{=}\PYG{n}{c0}\PYG{p}{,}
                   \PYG{n}{controller}\PYG{o}{=}\PYG{n}{time\PYGZus{}step\PYGZus{}size}\PYG{p}{,}
                   \PYG{n}{method}\PYG{o}{=}\PYG{n}{BackwardEuler}\PYG{p}{(}\PYG{n}{SimpleNewtonSolver}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The only distinction between this and the explicit methods is that the \sphinxcode{\sphinxupquote{BackwardEuler}} instance is built with a
\sphinxcode{\sphinxupquote{SimpleNewtonSolver}} object for solving the nonlinear system.
This simplicity is present in this case because we are letting Spitfire use a default dense linear solver (LU factorization and back-solution with LAPACK)
and a finite difference approximation to the Jacobian matrix.
In cases where a dense solver is appropriate this is a convenient option that will work very generally.

However, the challenge in efficiently using implicit methods for large problems is that the dense linear solver and
finite differenced Jacobian will not scale well.
For problems like nonpremixed flamelets described in the combustion section, this strategy is completely impractical.
Even in cases like the homogeneous reactors (also in the combustion section), where LAPACK is used, the finite
difference approximation to the Jacobian is too expensive and scales poorly with problem size.
For these reasons Spitfire provides the option of customizing the linear solver details.

As discussed above, solution of the linear system can often be broken down into a \sphinxcode{\sphinxupquote{setup}} phase and a \sphinxcode{\sphinxupquote{solve}} phase.
The setup phase might involve evaluation and factorization of the Jacobian matrix or assembly of a precoditioning matrix (for a Krylov solver).
The solve phase might involve back-solution with a direct solver such as LU, sparse LU, or a specialized direct algorithm,
or it might use a Krylov method like GMRES, CG, BiCGStab, \sphinxstyleemphasis{etc.}, possibly in a matrix-free manner.
Spitfire builds the separation of the \sphinxcode{\sphinxupquote{setup}} and \sphinxcode{\sphinxupquote{solve}} phases into the abstraction.

For a simple example of an implicit method with a customized linear solver, see the \sphinxtitleref{demo/time\_integration/chemistry\_abc\_implicit.py} script.
In this script a \sphinxcode{\sphinxupquote{ChemistryProblem}} class we use LAPACK LU factorization of the Jacobian matrix, computed from a closed analytical result.
A \sphinxcode{\sphinxupquote{lhs\_inverse\_op}} is stored in the \sphinxcode{\sphinxupquote{setup}} phase when we build the augmented Jacobian matrix, \(\bar{p}\boldsymbol{\mathcal{N}}_{\boldsymbol{q}} - \mathrm{I}\),
and it is then used when we compute the solution of the linear system given a residual argument.
Note that the \sphinxcode{\sphinxupquote{setup}} method takes two arguments: the prefactor \(\bar{p}\) and the state vector.
The prefactor, \(\bar{p}=ph\), is provided to this function when called by the \sphinxcode{\sphinxupquote{Governor}} and/or \sphinxcode{\sphinxupquote{NonlinearSolver}} and incorporates
the temporal discretization coefficient \(p\) from the \sphinxcode{\sphinxupquote{TimeStepper}} and time step \(h\) from the \sphinxcode{\sphinxupquote{Governor}}.
The \sphinxcode{\sphinxupquote{solve}} method then takes only the residual vector and produces the solution to the linear problem.
These methods are fed to the \sphinxcode{\sphinxupquote{Governor}}’s integrate method as the \sphinxcode{\sphinxupquote{projector\_setup}} and \sphinxcode{\sphinxupquote{projector\_solve}} arguments.
This demonstration shows how to use the LAPACK method as well as a simple (silly in this case) diagonal approximation of the Jacobian,
which is a common simple preconditioner for Krylov methods.
Careful inspection of Spitfire’s output for those cases shows that using the diagonal approximation increases the required
nonlinear iteration count from 170 (LU of the full Jacobian) to 276, over a 60\% increase (the linear solve does not provide a good direction for the Newton update).
The version that uses LAPACK is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ChemistryProblem}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    This class defines the right\PYGZhy{}hand side, setup, and solve methods for implicit methods with custom linear solvers}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{k\PYGZus{}ab}\PYG{p}{,} \PYG{n}{k\PYGZus{}bc}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}k\PYGZus{}ab} \PYG{o}{=} \PYG{n}{k\PYGZus{}ab}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}k\PYGZus{}bc} \PYG{o}{=} \PYG{n}{k\PYGZus{}bc}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}lhs\PYGZus{}inverse\PYGZus{}op} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}identity\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{rhs}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{c\PYGZus{}a} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{c\PYGZus{}b} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{q\PYGZus{}1} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}k\PYGZus{}ab} \PYG{o}{*} \PYG{n}{c\PYGZus{}a}
        \PYG{n}{q\PYGZus{}2} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}k\PYGZus{}bc} \PYG{o}{*} \PYG{n}{c\PYGZus{}a} \PYG{o}{*} \PYG{n}{c\PYGZus{}b}
        \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{q\PYGZus{}1} \PYG{o}{\PYGZhy{}} \PYG{n}{q\PYGZus{}2}\PYG{p}{,}
                         \PYG{n}{q\PYGZus{}1} \PYG{o}{\PYGZhy{}} \PYG{n}{q\PYGZus{}2}\PYG{p}{,}
                         \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{q\PYGZus{}2}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{setup\PYGZus{}lapack\PYGZus{}lu}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{prefactor}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{c\PYGZus{}a} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{c\PYGZus{}b} \PYG{o}{=} \PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{dq1\PYGZus{}da} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}k\PYGZus{}ab}
        \PYG{n}{dq1\PYGZus{}db} \PYG{o}{=} \PYG{l+m+mf}{0.}
        \PYG{n}{dq1\PYGZus{}dc} \PYG{o}{=} \PYG{l+m+mf}{0.}
        \PYG{n}{dq2\PYGZus{}da} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}k\PYGZus{}bc} \PYG{o}{*} \PYG{n}{c\PYGZus{}b}
        \PYG{n}{dq2\PYGZus{}db} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}k\PYGZus{}bc} \PYG{o}{*} \PYG{n}{c\PYGZus{}a}
        \PYG{n}{dq2\PYGZus{}dc} \PYG{o}{=} \PYG{l+m+mf}{0.}
        \PYG{n}{J} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{dq1\PYGZus{}da} \PYG{o}{\PYGZhy{}} \PYG{n}{dq2\PYGZus{}da}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dq1\PYGZus{}db} \PYG{o}{\PYGZhy{}} \PYG{n}{dq2\PYGZus{}db}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dq1\PYGZus{}dc} \PYG{o}{\PYGZhy{}} \PYG{n}{dq2\PYGZus{}dc}\PYG{p}{]}\PYG{p}{,}
                      \PYG{p}{[}\PYG{n}{dq1\PYGZus{}da} \PYG{o}{\PYGZhy{}} \PYG{n}{dq2\PYGZus{}da}\PYG{p}{,} \PYG{n}{dq1\PYGZus{}db} \PYG{o}{\PYGZhy{}} \PYG{n}{dq2\PYGZus{}db}\PYG{p}{,} \PYG{n}{dq1\PYGZus{}dc} \PYG{o}{\PYGZhy{}} \PYG{n}{dq2\PYGZus{}dc}\PYG{p}{]}\PYG{p}{,}
                      \PYG{p}{[}\PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{dq2\PYGZus{}da}\PYG{p}{,} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{dq2\PYGZus{}db}\PYG{p}{,} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{dq2\PYGZus{}dc}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

        \PYG{n}{linear\PYGZus{}op} \PYG{o}{=} \PYG{n}{prefactor} \PYG{o}{*} \PYG{n}{J} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}identity\PYGZus{}matrix}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}lhs\PYGZus{}inverse\PYGZus{}op} \PYG{o}{=} \PYG{n}{lapack\PYGZus{}lu\PYGZus{}factor}\PYG{p}{(}\PYG{n}{linear\PYGZus{}op}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} the [:2] part here is just an implementation detail of scipy\PYGZsq{}s lapack wrapper}

    \PYG{k}{def} \PYG{n+nf}{solve\PYGZus{}lapack\PYGZus{}lu}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{residual}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{lapack\PYGZus{}lu\PYGZus{}solve}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}lhs\PYGZus{}inverse\PYGZus{}op}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                               \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}lhs\PYGZus{}inverse\PYGZus{}op}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
                               \PYG{n}{residual}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kc}{True}      \PYG{c+c1}{\PYGZsh{} the , 1, True parts here are how many iterations were needed and success/failure of the solver}

    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

    \PYG{n}{governor}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{right\PYGZus{}hand\PYGZus{}side}\PYG{o}{=}\PYG{n}{problem}\PYG{o}{.}\PYG{n}{rhs}\PYG{p}{,}
               \PYG{n}{initial\PYGZus{}condition}\PYG{o}{=}\PYG{n}{c0}\PYG{p}{,}
               \PYG{n}{controller}\PYG{o}{=}\PYG{n}{time\PYGZus{}step\PYGZus{}size}\PYG{p}{,}
               \PYG{n}{method}\PYG{o}{=}\PYG{n}{ESDIRK64}\PYG{p}{(}\PYG{n}{SimpleNewtonSolver}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
               \PYG{n}{projector\PYGZus{}setup}\PYG{o}{=}\PYG{n}{problem}\PYG{o}{.}\PYG{n}{setup\PYGZus{}lapack\PYGZus{}lu}\PYG{p}{,}
               \PYG{n}{projector\PYGZus{}solve}\PYG{o}{=}\PYG{n}{problem}\PYG{o}{.}\PYG{n}{solve\PYGZus{}lapack\PYGZus{}lu}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Solving Combustion Problems in Spitfire}
\label{\detokenize{combustion:solving-combustion-problems-in-spitfire}}\label{\detokenize{combustion::doc}}
This section describes setting up homogeneous reactors and non-premixed flamelets and computing steady and unsteady solutions,
and the following section discusses relevant combustion theory.


\section{Chemical Mechanisms}
\label{\detokenize{combustion:chemical-mechanisms}}
The first step to solving any combustion problem in Spitfire is setting up the chemical mechanism,
which contains all of the necessary information regarding thermodynamics and chemical kinetics.
Spitfire uses the Python interface of \sphinxhref{https://cantera.org/}{cantera} as well as the cantera XML description of chemical mechanisms.

Having obtained a cantera XML file for your chemical mechanism,
next import the \sphinxcode{\sphinxupquote{ChemicalMechanismSpec}} class and construct an instance of it
with the file path to the XML and the species group.
For example, as seen in the demonstration script, \sphinxcode{\sphinxupquote{spitfire/demo/reactors/docs-simple-example-1.py}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{spitfire} \PYG{k}{import} \PYG{n}{ChemicalMechanismSpec}
\PYG{n}{sm} \PYG{o}{=} \PYG{n}{ChemicalMechanismSpec}\PYG{p}{(}\PYG{n}{cantera\PYGZus{}xml}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mechanisms/h2\PYGZhy{}burke.xml}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{group\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h2\PYGZhy{}burke}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Streams \& Mixing}
\label{\detokenize{combustion:streams-mixing}}
Having constructed a \sphinxcode{\sphinxupquote{ChemicalMechanismSpec}} instance, we need to specify thermochemical properties of mixtures.
In Spitfire this is accomplished with \sphinxstyleemphasis{streams} created with a \sphinxcode{\sphinxupquote{ChemicalMechanismSpec}} instance.
For example, a mixture of pure Hydrogen is created and its temperature and pressure set with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{h2} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2:1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{h2}\PYG{o}{.}\PYG{n}{TP} \PYG{o}{=} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{l+m+mi}{101325}
\end{sphinxVerbatim}

To specify the temperature and pressure at the same time as the composition (mole fractions here), the stream could be created with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{h2} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TPX}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{l+m+mi}{101325}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2:1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Streams are instances of the \sphinxcode{\sphinxupquote{Quantity}} class in Cantera’s Python interface.
The \sphinxcode{\sphinxupquote{stream}} method on \sphinxcode{\sphinxupquote{ChemicalMechanismSpec}} can be given temperature, pressure, and composition or any combination Cantera allows.
See \sphinxhref{https://www.cantera.org/docs/sphinx/html/cython/importing.html\#cantera.Quantity}{Cantera documentation for options} regarding the construction of \sphinxcode{\sphinxupquote{Quantity}} instances and setting/getting thermochemical properties.

For convenience, Spitfire makes it easy to create a stream of air at standard temperature and pressure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{air} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{(}\PYG{n}{stp\PYGZus{}air}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

New streams can be composed by mixing existing streams.
Mixing can be done on a mass or mole basis, isobarically or isometrically, to attain a particular equivalence ratio or mixture fraction, etc.

To mix two streams, say, one unit mass of \sphinxcode{\sphinxupquote{h2}} and two unit masses of \sphinxcode{\sphinxupquote{air}}, at constant pressure, call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mix} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{mix\PYGZus{}streams}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{n}{h2}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{air}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

To mix by mole at constant energy and volume (thus pressurizing the mixture):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mix2} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{mix\PYGZus{}streams}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{n}{h2}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{air}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mole}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Streams can be mixed in additional ways which are discussed in the following sections.


\section{Homogeneous Reactors}
\label{\detokenize{combustion:homogeneous-reactors}}

\subsection{A simple autoignition example}
\label{\detokenize{combustion:a-simple-autoignition-example}}
Starting from the point of constructing streams for air and fuel, we can mix them by specifying an equivalence ratio, \(\phi\).
The \sphinxhref{https://en.wikipedia.org/wiki/Air\%E2\%80\%93fuel\_ratio\#Fuel\%E2\%80\%93air\_equivalence\_ratio\_(\%CF\%95)}{equivalence ratio} is the actual fuel-to-oxidizer ratio divided by the stoichiometric value.
With the \sphinxcode{\sphinxupquote{h2}} and \sphinxcode{\sphinxupquote{air}} streams, setting it to one yields a stoichiometric mixture of hydrogen and air,
meaning there is just the right amount of oxygen to burn all of the fuel in an ideal combustion reaction:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mix} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{mix\PYGZus{}for\PYGZus{}equivalence\PYGZus{}ratio}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{,} \PYG{n}{air}\PYG{p}{)}
\end{sphinxVerbatim}

The equivalence ratio varies from zero to infinity, with lean (too much oxygen) and rich (too much fuel) mixtures below and above one, respectively.
The \sphinxstyleemphasis{normalized} equivalence ratio, \(\Phi=\phi/(\phi+1)\), however, varies more nicely from zero to one, and stoichiometric mixtures correspond to \(\phi=1\) and \(\Phi=0.5\).
As it may be more convenient in some cases, the normalized equivalence ratio can also be used for mixing fuel and air:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mix} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{mix\PYGZus{}for\PYGZus{}normalized\PYGZus{}equivalence\PYGZus{}ratio}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{,} \PYG{n}{air}\PYG{p}{)}
\end{sphinxVerbatim}

The temperature and pressure of the fuel-air blend can then be set with \sphinxcode{\sphinxupquote{mix.TP = 1200, 101325}}.

Now we are ready to fill a reactor with this mixture and simulate its evolution.
First, build a homogeneous reactor that holds a constant pressure (isobaric), has impermeable (no mass flow - closed) and adiabatic (no heat flow) walls:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{spitfire} \PYG{k}{import} \PYG{n}{HomogeneousReactor}
\PYG{n}{r} \PYG{o}{=} \PYG{n}{HomogeneousReactor}\PYG{p}{(}\PYG{n}{sm}\PYG{p}{,} \PYG{n}{mix}\PYG{p}{,}
                       \PYG{n}{configuration}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isobaric}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{heat\PYGZus{}transfer}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adiabatic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{mass\PYGZus{}transfer}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{closed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Now to run a simple autoignition simulation and plot the temperature history along with several species mass fractions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{r}\PYG{o}{.}\PYG{n}{integrate\PYGZus{}to\PYGZus{}steady\PYGZus{}after\PYGZus{}ignition}\PYG{p}{(}\PYG{n}{plot}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Adding the \sphinxcode{\sphinxupquote{plot}} argument shows the temperature evolution in the top panel and species mass fractions in the bottom panel, as in Figure \hyperref[\detokenize{combustion:figure-simple-example-easyplot}]{Fig.\@ \ref{\detokenize{combustion:figure-simple-example-easyplot}}}.
The occurence of ignition at around 0.05 milliseconds can be seen in the sudden temperature spike, consumption of hydrogen and oxygen, and production of water.
Observe that the hydrogen radical, H, a major chain carrying species, is produced prior to ignition and consumed afterwards, with its mass fraction peaking just at the onset of the temperature spike.
The ignition delay may be printed with the following command, \sphinxcode{\sphinxupquote{print('Ignition delay: \{:.1f\} us'.format(r.ignition\_delay() * 1.e6))}}.
The precise number is 51.7 microseconds, matching our estimate of 0.05 milliseconds from the plot.
This simple tutorial can be run in total with the demonstration script, \sphinxcode{\sphinxupquote{spitfire/demo/reactors/docs-simple-example-1.py}}.
This script is reproduced here as a summary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{spitfire} \PYG{k}{import} \PYG{n}{ChemicalMechanismSpec}\PYG{p}{,} \PYG{n}{HomogeneousReactor}

\PYG{n}{sm} \PYG{o}{=} \PYG{n}{ChemicalMechanismSpec}\PYG{p}{(}\PYG{n}{cantera\PYGZus{}xml}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mechanisms/h2\PYGZhy{}burke.xml}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{group\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h2\PYGZhy{}burke}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{h2} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2:1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{air} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{(}\PYG{n}{stp\PYGZus{}air}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{mix} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{mix\PYGZus{}for\PYGZus{}equivalence\PYGZus{}ratio}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{,} \PYG{n}{air}\PYG{p}{)}
\PYG{n}{mix}\PYG{o}{.}\PYG{n}{TP} \PYG{o}{=} \PYG{l+m+mi}{1200}\PYG{p}{,} \PYG{l+m+mi}{101325}

\PYG{n}{r} \PYG{o}{=} \PYG{n}{HomogeneousReactor}\PYG{p}{(}\PYG{n}{sm}\PYG{p}{,} \PYG{n}{mix}\PYG{p}{,}
                       \PYG{n}{configuration}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isobaric}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{heat\PYGZus{}transfer}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adiabatic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{mass\PYGZus{}transfer}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{closed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{r}\PYG{o}{.}\PYG{n}{integrate\PYGZus{}to\PYGZus{}steady\PYGZus{}after\PYGZus{}ignition}\PYG{p}{(}\PYG{n}{plot}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ignition delay: }\PYG{l+s+si}{\PYGZob{}:.1f\PYGZcb{}}\PYG{l+s+s1}{ us}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{ignition\PYGZus{}delay}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{1.e6}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=640\sphinxpxdimen,height=480\sphinxpxdimen]{{simple_example_isobaric_adiabatic_closed_plot}.png}
\caption{Example figure produced by \sphinxcode{\sphinxupquote{r.integrate\_to\_steady\_after\_ignition(plot={[}'H2', 'O2', 'H2O', 'OH', 'H'{]})}}.}\label{\detokenize{combustion:id6}}\label{\detokenize{combustion:figure-simple-example-easyplot}}\end{figure}


\subsection{In-situ processing and analysis}
\label{\detokenize{combustion:in-situ-processing-and-analysis}}
In the previous example we constructed a reactor and observed its evolution, quickly obtaining a plot of temperature and species mass fraction evolution.
To do more detailed analysis, we’ll need to save state variables such as temperature and mass fractions for later use.
Start this next example in the same way, blending fuel and air streams and then using the mixture to construct a homogeneous reactor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{spitfire} \PYG{k}{import} \PYG{n}{ChemicalMechanismSpec}\PYG{p}{,} \PYG{n}{HomogeneousReactor}

\PYG{n}{sm} \PYG{o}{=} \PYG{n}{ChemicalMechanismSpec}\PYG{p}{(}\PYG{n}{cantera\PYGZus{}xml}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mechanisms/h2\PYGZhy{}burke.xml}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{group\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h2\PYGZhy{}burke}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{h2} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2:1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{air} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{stream}\PYG{p}{(}\PYG{n}{stp\PYGZus{}air}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{mix} \PYG{o}{=} \PYG{n}{sm}\PYG{o}{.}\PYG{n}{mix\PYGZus{}for\PYGZus{}equivalence\PYGZus{}ratio}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{,} \PYG{n}{air}\PYG{p}{)}
\PYG{n}{mix}\PYG{o}{.}\PYG{n}{TP} \PYG{o}{=} \PYG{l+m+mi}{1200}\PYG{p}{,} \PYG{l+m+mi}{101325}

\PYG{n}{r} \PYG{o}{=} \PYG{n}{HomogeneousReactor}\PYG{p}{(}\PYG{n}{sm}\PYG{p}{,} \PYG{n}{mix}\PYG{p}{,}
                       \PYG{n}{configuration}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isobaric}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{heat\PYGZus{}transfer}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adiabatic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{mass\PYGZus{}transfer}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{closed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

This time, before integrating the reactor to a steady state, we will tell Spitfire to save data.
We will save the temperature, mass fractions, and species net production rates.
This is done with the \sphinxcode{\sphinxupquote{insitu\_process\_quantity}} method, which allows us to tell Spitfire to compute thermochemical quantities \sphinxstyleemphasis{in situ} during the simulation.
After integration, we can obtain the saved quantities with the \sphinxcode{\sphinxupquote{trajectory\_data}} method.
To plot quantities over simulation time, we can use \sphinxcode{\sphinxupquote{t = r.solution\_times}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{r}\PYG{o}{.}\PYG{n}{insitu\PYGZus{}process\PYGZus{}quantity}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temperature}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mass fractions}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{production rates}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{r}\PYG{o}{.}\PYG{n}{integrate\PYGZus{}to\PYGZus{}steady\PYGZus{}after\PYGZus{}ignition}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{solution\PYGZus{}times} \PYG{o}{*} \PYG{l+m+mf}{1.e6}  \PYG{c+c1}{\PYGZsh{} scale to microseconds}
\PYG{n}{T} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{trajectory\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temperature}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{yH} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{trajectory\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mass fraction H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{wH} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{trajectory\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{production rate H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Importing \sphinxcode{\sphinxupquote{import matplotlib.pyplot as plt}}, we can then plot, for example, the production rate of the hydrogen radical over the reactor temperature.
This produces Figure \hyperref[\detokenize{combustion:figure-simple-example-prodrate-over-t}]{Fig.\@ \ref{\detokenize{combustion:figure-simple-example-prodrate-over-t}}}.
This figure shows that the peak production rate of hydrogen radical occurs at around 200 K above the initial temperature:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{n}{wH}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T (K)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{prod. rate H (kg/m3/s)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=640\sphinxpxdimen,height=480\sphinxpxdimen]{{simple_example_isobaric_adiabatic_closed_wHoverT}.png}
\caption{Net production rate of hydrogen radical over the reactor temperature in an isobaric, adiabatic, closed autoignition simulation.}\label{\detokenize{combustion:id7}}\label{\detokenize{combustion:figure-simple-example-prodrate-over-t}}
\begin{sphinxlegend}
A number of quantities may be computed \sphinxstyleemphasis{in situ} with the \sphinxcode{\sphinxupquote{insitu\_process\_quantity}} method using either cantera or Griffon.
These are listed below.
\end{sphinxlegend}
\end{figure}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{'temperature'}}: the reactor temperature

\item {} 
\sphinxcode{\sphinxupquote{'pressure'}}: the reactor pressure

\item {} 
\sphinxcode{\sphinxupquote{'density'}}: the mass density of the mixture

\item {} 
\sphinxcode{\sphinxupquote{'mass fractions'}}: species mass fractions - obtain a particular species value with \sphinxcode{\sphinxupquote{'mass fraction A'}}

\item {} 
\sphinxcode{\sphinxupquote{'mole fractions'}}: species mole fractions - obtain a particular species value with \sphinxcode{\sphinxupquote{'mole fraction A'}}

\item {} 
\sphinxcode{\sphinxupquote{'energy'}}: the specific energy of the mixture

\item {} 
\sphinxcode{\sphinxupquote{'enthalpy'}}: the specific enthalpy of the mixture

\item {} 
\sphinxcode{\sphinxupquote{'heat capacity cv'}}: the specific constant-volume heat capacity of the mixture

\item {} 
\sphinxcode{\sphinxupquote{'heat capacity cp'}}: the specific constant-pressure heat capacity of the mixture

\item {} 
\sphinxcode{\sphinxupquote{'production rates'}}: species net mass production rates - obtain a particular species value with \sphinxcode{\sphinxupquote{'production rate A'}}

\item {} 
\sphinxcode{\sphinxupquote{'heat release rate'}}: chemical right-hand side component of the temperature equation. Energy-based for isochoric reactors, enthalpy-based for isobaric. Scaled by the appropriate volumetric heat capacity.

\item {} 
\sphinxcode{\sphinxupquote{'eigenvalues'}}: the full set of eigenvalues of the Jacobian matrix of the chemical source terms

\end{itemize}

There are two other types of quantities that can be processed \sphinxstyleemphasis{in situ}.
First, one may calculate any quantity computable by the cantera gas phase - see \sphinxhref{https://www.cantera.org/docs/sphinx/html/cython/importing.html\#cantera.Quantity}{Cantera documentation for options}.
For instance, \sphinxcode{\sphinxupquote{r.insitu\_process\_cantera\_method('cp\_mass')}} will save the result of the \sphinxcode{\sphinxupquote{cp\_mass}} method (which computes the specific heat capacity at constant pressure) at each state to the \sphinxcode{\sphinxupquote{'cp\_mass'}} label.
Any label may be specified as in \sphinxcode{\sphinxupquote{r.insitu\_process\_cantera\_method(label='cpm', method='cp\_mass')}}.
This triggers calculation of \sphinxcode{\sphinxupquote{cp\_mass}} at every step and saves the data to the label, \sphinxcode{\sphinxupquote{'cpm'}}.
In addition to simple scalar methods such as \sphinxcode{\sphinxupquote{cp\_mass}}, one can compute particular elements of vector quantities such as elementary reaction rates.
The line, \sphinxcode{\sphinxupquote{r.insitu\_process\_cantera\_method(label='qCB', method='net\_rates\_of\_progress', index=0)}} will save the zeroth (first…) element of the vector computed by the \sphinxcode{\sphinxupquote{net\_rates\_of\_progress}} cantera method, and label it \sphinxcode{\sphinxupquote{qCB}}.
For vectors of species quantities, the \sphinxcode{\sphinxupquote{index}} argument can be the species’ name, such as in \sphinxcode{\sphinxupquote{r.insitu\_process\_cantera\_method(label='cH', method='concentrations', index='H')}}, which computes the molar concentration of species H.
Here are all four examples of general cantera-based processing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{r}\PYG{o}{.}\PYG{n}{insitu\PYGZus{}process\PYGZus{}cantera\PYGZus{}method}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cp\PYGZus{}mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{r}\PYG{o}{.}\PYG{n}{insitu\PYGZus{}process\PYGZus{}cantera\PYGZus{}method}\PYG{p}{(}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cpm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cp\PYGZus{}mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{r}\PYG{o}{.}\PYG{n}{insitu\PYGZus{}process\PYGZus{}cantera\PYGZus{}method}\PYG{p}{(}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qCB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{net\PYGZus{}rates\PYGZus{}of\PYGZus{}progress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{r}\PYG{o}{.}\PYG{n}{insitu\PYGZus{}process\PYGZus{}cantera\PYGZus{}method}\PYG{p}{(}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{concentrations}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

And this code plots the rate of the chain-branching reaction, \sphinxcode{\sphinxupquote{H + O2 \textless{}-\textgreater{} O + OH}}, over time along with temperature in two panels.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{211}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{semilogx}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{qCB}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{net rate (mol/m3/s)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H + O2 \PYGZlt{}\PYGZhy{}\PYGZgt{} O + OH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{212}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{semilogx}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t (us)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T (K)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

The final type of \sphinxstyleemphasis{in situ} processing available is chemical explosive mode analysis (CEMA).
To trigger CEMA, call \sphinxcode{\sphinxupquote{r.insitu\_process\_cema()}}.
There are several additional arguments that enable advanced analysis but we do not cover them here.
Calling \sphinxcode{\sphinxupquote{r.insitu\_process\_cema()}} without any arguments triggers only the most basic technique of CEMA, which is to compute the ‘explosive eigenvalue’.
The explosive eigenvalue may be retrieved with ‘’r.trajectory\_data(‘cema-lexp1’)’‘.
See the demonstration script, \sphinxcode{\sphinxupquote{spitfire/demo/reactors/docs-example-2.py}}, for more details and several plots.


\subsection{Ignition delay calculations}
\label{\detokenize{combustion:ignition-delay-calculations}}
A common task of combustion codes is to compute the ignition delay - how long it takes a mixture to ignite.
Spitfire’s reactor class makes this straightforward with the \sphinxcode{\sphinxupquote{compute\_ignition\_delay()}} method.
See the following demonstration scripts in the \sphinxcode{\sphinxupquote{spitfire/demo/reactors/}} directory for examples of computing ignition delays across ranges of temperature, pressure, mechanism, etc.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{spitfire/demo/reactors/ignition-delay-profiles-methane-mechanism-comparison.py}}: compares the dependence of ignition delay on temperature for four mechanisms of methane combustion

\item {} 
\sphinxcode{\sphinxupquote{ignition-delay-profiles-DME-negative-temp-coeff.py}}: demonstrates negative temperature coefficient (NTC) behavior of dimethyl ether (DME) mixtures and the dependency of NTC strength on pressure, as in Figure \hyperref[\detokenize{combustion:figure-dme-ntc-curves}]{Fig.\@ \ref{\detokenize{combustion:figure-dme-ntc-curves}}}

\item {} 
\sphinxcode{\sphinxupquote{ignition-delay-profiles-biodiesel-negative-temp-coeff.py}}: performs a similar analysis to the DME case for biodiesel mixtures

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=640\sphinxpxdimen,height=480\sphinxpxdimen]{{dme_ntc_curves}.png}
\caption{Ignition delay curves of dimethyl ether mixtures for a number of pressures, demonstrating both the negative temperature coefficient behavior and its sensitivity to pressure}\label{\detokenize{combustion:id8}}\label{\detokenize{combustion:figure-dme-ntc-curves}}\end{figure}


\subsection{Computing ignition-extinction curves}
\label{\detokenize{combustion:computing-ignition-extinction-curves}}
Another common task is to assess the presence of multiple steady states along ignition-extinction curves.
In the following demonstration scripts we build adiabatic reactors with mass flow at varying mixing (residence) times.
By increasing the mixing time from zero to infinity and computing the steady state temperature along the way, we compute the ignition branch.
Reversing the direction gives the extinction branch.
The scripts below show how one can compute ignition-extinction curves with Spitfire.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{spitfire/demo/reactors/ignext-hydrogen-mechanism-comparison.py}}: compares ignition-extinction curves of three hydrogen mechanisms

\item {} 
\sphinxcode{\sphinxupquote{spitfire/demo/reactors/ignext-ethylene-mechanism-comparison.py}}: compares ignition-extinction curves of three ethylene mechanisms

\end{itemize}


\subsection{Time-dependent parameters}
\label{\detokenize{combustion:time-dependent-parameters}}
In the ignition-extinction demonstration scripts we build reactors with constant parameters (e.g. mixing time, feed temperature).
It is simple to specify the reactor parameters as functions of time.
Instead of providing a value for a parameter, provide a callable object such as a function, lambda, or class with the \sphinxcode{\sphinxupquote{\_\_call\_\_}} method defined (note that the first argument in the function must be time, and only one argument is given).
For example, the \sphinxcode{\sphinxupquote{spitfire/demo/reactors/open-reactor-oscillatory-feed-temperature.py}} script specifies the feed temperature as a sine wave of time with a lambda.
This slow oscillation of the feed temperature causes the reactor to periodically ignite and extinguish as shown in Figure \hyperref[\detokenize{combustion:figure-oscillating-feed-temperature}]{Fig.\@ \ref{\detokenize{combustion:figure-oscillating-feed-temperature}}}.
Also note that in this script we do not compute a steady solution, instead using the \sphinxcode{\sphinxupquote{integrate\_to\_time}} method of the reactor to integrate only until reaching a specified simulation time.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=640\sphinxpxdimen,height=480\sphinxpxdimen]{{oscillatory_feed_temp_example}.png}
\caption{Periodic ignition and extinction in a reactor due to slow oscillation of the feed stream temperature}\label{\detokenize{combustion:id9}}\label{\detokenize{combustion:figure-oscillating-feed-temperature}}\end{figure}


\subsection{Reactor types}
\label{\detokenize{combustion:reactor-types}}
The demonstration scripts in \sphinxcode{\sphinxupquote{spitfire/demo/reactors/}} that haven’t been covered in previous sections exist to showcase some of the reactor types available in Spitfire.
Spitfire provides three types of specifications and twelve types of reactors in total:
\begin{itemize}
\item {} 
\sphinxstylestrong{configuration}: whether the reactor is isobaric (constant pressure) or isochoric (constant volume)

\item {} 
\sphinxstylestrong{heat\_transfer}: whether the reactor is adiabatic (no heat flow), isothermal (constant temperature), or diathermal (convective and radiative heat transfer with external media)

\item {} 
\sphinxstylestrong{mass\_transfer}: whether the reactor is open (mass flow with specified mixing time and inflow stream) or closed (no mass flow)

\end{itemize}

Spitfire requires diathermal reactors to have a geometry.
The shape is relevant because it determines ratio of surface area to volume, which plays a role in balancing volumetric heat release due to chemistry against heat transfer across a surface.
The \sphinxcode{\sphinxupquote{spitfire/demo/reactors/open-reactors-isobaric-diathermal-shapes.py}} example shows the impact of reactor geometry, with high surface areas corresponding to stronger heat loss.

Among the other undiscussed demonstrations, two perform noteworthy analyses.
\sphinxcode{\sphinxupquote{spitfire/demo/reactors/open-reactors-isobaric-isothermal-with-insitu-processing.py}} gives an example of detailed chemical explosive mode analysis on an isothermal reactor.
\sphinxcode{\sphinxupquote{spitfire/demo/reactors/open-reactor-oscillatory-convection.py}} involves kinetics, mass transfer (a hot feed stream), and heat transfer (convective losses to a cool fluid) simultaneously.
Furthermore the convection coefficient oscillates in time to cause periodic ignition and extinction.


\section{Non-premixed Flamelets}
\label{\detokenize{combustion:non-premixed-flamelets}}
Spitfire provides a number of convenient methods of solving steady and unsteady nonpremixed flamelets, both adiabatic and nonadiabatic.
A special method is provided for building adiabatic steady flamelet libraries, a common task required for large eddy simulation and flow-resolved direct numerical simulation of combustion systems.
The first demonstration discussed here, in \sphinxcode{\sphinxupquote{spitfire/demo/flamelet/adiabatic-table-generation.py}}, uses this method to build an adiabiatic flamelet library for a hydrogen-air system.
With the \sphinxcode{\sphinxupquote{build\_adiabatic\_slfm\_table}} method, we first build a dictionary with a mechanism wrapper, oxidizer and fuel streams (as discussed in prior demonstrations), and specify a pressure and number of grid points to discretize mixture fraction space.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{flamelet\PYGZus{}specs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mech\PYGZus{}spec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{m}\PYG{p}{,}
                  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pressure}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{pressure}\PYG{p}{,}
                  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{oxy\PYGZus{}stream}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{air}\PYG{p}{,}
                  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fuel\PYGZus{}stream}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{fuel}\PYG{p}{,}
                  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grid\PYGZus{}points}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{34}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Next we specify the thermochemical quantities and transport properties to compute on the table.
A common set required for flame simulation, which typically requires at least density and viscosity, is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{quantities} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temperature}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{density}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mass fraction OH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{viscosity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

As in the Python script, we then use the table builder method as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{table\PYGZus{}coarse} \PYG{o}{=} \PYG{n}{build\PYGZus{}adiabatic\PYGZus{}slfm\PYGZus{}table}\PYG{p}{(}\PYG{n}{flamelet\PYGZus{}specs}\PYG{p}{,}
                                          \PYG{n}{quantities}\PYG{p}{,}
                                          \PYG{n}{lower\PYGZus{}chimax}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}1}\PYG{p}{,}
                                          \PYG{n}{upper\PYGZus{}chimax}\PYG{o}{=}\PYG{l+m+mf}{1.e4}\PYG{p}{,}
                                          \PYG{n}{n\PYGZus{}chimax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\end{sphinxVerbatim}

This particular call specifies the flamelet specifications, tabulated quantities, bounds of the dissipation rate, and the number of dissipation rates to save.
Only six are saved here for the demonstration, while a call shortly afterwards builds a finer table with forty dissipation rates.
The following matplotlib commands in the Python script produce the plots below,
one showing the profiles of each quantity in mixture fraction and the other showing contours on the mixture fraction and dissipation rate space.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=660\sphinxpxdimen]{{steady_adiabatic_h2_flamelet_profiles}.png}
\caption{Selected profiles of several quantities over mixture fraction space for steady, adiabatic hydrogen flamelets}\label{\detokenize{combustion:id10}}\label{\detokenize{combustion:figure-steady-adiabatic-h2-flamelet-profiles}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=660\sphinxpxdimen]{{steady_adiabatic_h2_flamelet_contours}.png}
\caption{Contours of several quantities over mixture fraction and dissipation rate space for steady, adiabatic hydrogen flamelets}\label{\detokenize{combustion:id11}}\label{\detokenize{combustion:figure-steady-adiabatic-h2-flamelet-contours}}\end{figure}

The \sphinxcode{\sphinxupquote{build\_adiabatic\_slfm\_table}} method is the simplest option for building adiabatic, steady flamelet libraries.
In the \sphinxcode{\sphinxupquote{spitfire/demo/flamelet/steady-adiabatic-with-enthalpy-flux.py}} script, we use this function to build two libraries,
computed with or without the consistent enthalpy flux discussed in the theory section.
To enable the flux or not, we simply build the \sphinxcode{\sphinxupquote{flamelet\_specs}} object differently.
This allows a simple observation of the impact of the consistent enthalpy flux formulation on flamelet temperature profiles,
shown here in Figure \hyperref[\detokenize{combustion:figure-steady-adiabatic-h2-flamelet-contours}]{Fig.\@ \ref{\detokenize{combustion:figure-steady-adiabatic-h2-flamelet-contours}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=660\sphinxpxdimen]{{steady_adiabatic_h2_flamelet_profiles_enthalpy_flux}.png}
\caption{Comparison of temperature profiles of steady, adiabiatic hydrogen flamelets for several dissipation rates with and without the consistent enthalpy flux}\label{\detokenize{combustion:id12}}\label{\detokenize{combustion:figure-steady-adiabatic-h2-flamelet-profiles-enthalpy-flux}}\end{figure}

This documentation is in progress… TODO:
\begin{itemize}
\item {} 
steady, nonadiabatic demo (quasi steady heat loss)

\item {} 
make a nonadiabiatic demo with the transient heat loss formulation

\item {} 
unsteady, adiabatic with cema demo

\item {} 
steady coal flamelet demo

\item {} 
jupyter demos - clean up necessary

\end{itemize}


\chapter{Combustion Theory}
\label{\detokenize{combustion:combustion-theory}}
This section details the theory behind Spitfire’s combustion modeling capabilities.
We present the governing equations for homogeneous reactors and non-premixed flamelets
along with the underlying reaction rate laws and thermodynamic property models.


\section{Governing Equations for Homogeneous Reactors}
\label{\detokenize{combustion:governing-equations-for-homogeneous-reactors}}
Homogeneous, or ‘zero-dimensional,’ reactor models represent well-mixed combustion systems wherein there are no spatial gradients in any quantity describing the chemical mixture.
In such a system the temperature \(T\), pressure \(p\), and composition, expressed by the mass fractions \(\{Y_i\}\), are all homogeneous and a reactor may be modeled as a point in space whose properties vary only in time, \(t\).
Zero-dimensional systems are idealizations of very complex systems but have their place in the modeling of combustion processes.
In a lab setting this idealization can be approached with \sphinxstyleemphasis{jet-stirred reactors} (JSR, also commonly referred to as a continuous stirred tank reactor (CSTR), perfectly stirred reactor (PSR), and Longwell reactor) and \sphinxstyleemphasis{rapid compression machines} (RCM).
A JSR is a continuous stirred tank reactor to which reactants are fed and mixed rapidly through several opposed jets.
A JSR unit coupled with downstream gas chromatography and mass spectrometry can be used to quantify the composition of the chemical mixture as reaction proceeds.
Detailed models of combustion kinetics are developed through comparison with experimental data from such systems.
The rapid computational solution of kinetic models for simple, zero-dimensional reactors is of great fundamental importance to combustion modeling.

In Spitfire we model mixtures of ideal gases in twelve types of reactors distinguished by their \sphinxstyleemphasis{configuration}, \sphinxstyleemphasis{heat transfer}, and \sphinxstyleemphasis{mass transfer}.
We use \sphinxstyleemphasis{configuration} to distinguish isochoric, or constant-volume, reactors from isobaric, or constant-pressure, ones.
\sphinxstyleemphasis{Mass transfer} refers to a closed, or batch, reactor or an open reactor with mass flow at specified mean residence time.
Three types of \sphinxstyleemphasis{heat transfer} are available:
\begin{itemize}
\item {} 
adiabatic: a reactor with insulated walls that allow no heat transfer with the surroundings

\item {} 
isothermal: a reactor whose temperature is held exactly constant for all time

\item {} \begin{description}
\item[{diathermal: a reactor whose walls allow a finite rate of heat transfer by two modes}] \leavevmode\begin{itemize}
\item {} 
radiative heat transfer to a nearby surface

\item {} 
convective heat transfer to a fluid flowing around the reactor

\end{itemize}

\end{description}

\end{itemize}

Below we detail the equations governing isochoric and isobaric reactors with any pair of models for mass and transfer.
In all cases the ideal gas law applies,
\begin{equation}\label{equation:combustion:ideal_gas_law}
\begin{split}p = \rho R_\mathrm{mix} T,\end{split}
\end{equation}
where the mixture specific gas constant, \(R_\mathrm{mix}\), is the universal molar gas constant divided by the mixture molar mass,
\begin{equation}\label{equation:combustion:mixture_molar_mass}
\begin{split}M_\mathrm{mix} = \left(\sum_{i=1}^{n}\frac{Y_i}{M_i}\right)^{-1},\end{split}
\end{equation}
where \(M_i\) is the molar mass of species \(i\) in a mixture with \(n\) distinct species.
Additionally for all reactors the mass fractions, of which only \(n-1\) are independent, are related by
\begin{equation}\label{equation:combustion:Y_n_eqn}
\begin{split}Y_n = 1 - \sum_{i=1}^{n-1}Y_i.\end{split}
\end{equation}

\subsection{Isochoric Reactors}
\label{\detokenize{combustion:isochoric-reactors}}
Figure \hyperref[\detokenize{combustion:figure-isochoric-reactor-diagram}]{Fig.\@ \ref{\detokenize{combustion:figure-isochoric-reactor-diagram}}} diagrams an open, constant-volume reactor with diathermal walls.
The reactor has volume \(V\) and surface area \(A\).
Convective heat transfer is described by a fluid temperature \(T_\infty\) and convective heat transfer coefficient \(h\).
Radiative heat transfer is determined by the temperature of the surface, \(T_\mathrm{surf}\), and effective emissivity, \(\varepsilon\).
Finally, for an isochoric reactor, mass transfer is specified by the residence time \(\tau\), based on volumetric flow rate, and inflowing state
with temperature \(T_\mathrm{in}\), density \(\rho_\mathrm{in}\), and mass fractions \(\{Y_{i,\mathrm{in}}\}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=660\sphinxpxdimen]{{isochoric-reactor-diagram}.png}
\caption{Isochoric reactor with mass transfer and convective and radiative heat transfer}\label{\detokenize{combustion:id13}}\label{\detokenize{combustion:figure-isochoric-reactor-diagram}}\end{figure}

Isochoric reactors are governed by the following equations for the reactor density, temperature, and first \(n-1\) mass fractions.
\(\omega_i\) is the net mass production rate of species \(i\) due to chemical reactions,
\(c_v\) is the specific, isochoric heat capacity of the mixture,
and \(e_i\) and \(e_{i,\mathrm{in}}\) are the specific internal energy of species \(i\) in the feed and reactor.
\(\sigma\) is the Stefan-Boltzmann constant.
We solve these equations in Spitfire to maximize sparsity and minimize calculation cost of Jacobian matrices.
Recent work \sphinxcite{combustion:mj2018} has shown that the conservation error that results from solving a temperature equation instead of an energy equation is negligible when high-order time integration methods such as those in Spitfire are used.
Closed reactors are obtained by setting \(\tau\to\infty\).
Adiabatic reactors are obtained by setting \(h,\varepsilon\to0\).
Isothermal reactors are obtained by setting the entire right-hand side of the temperature equation to zero.
\begin{equation}\label{equation:combustion:isochoric_rho_eqn}
\begin{split}\frac{\partial \rho}{\partial t} = \frac{\rho_\mathrm{in} - \rho}{\tau},\end{split}
\end{equation}\begin{equation}\label{equation:combustion:isochoric_Yi_eqn}
\begin{split}\frac{\partial Y_i}{\partial t} = \frac{\rho_\mathrm{in}}{\rho}\frac{Y_{i,\mathrm{in}} - Y_i}{\tau} + \frac{\omega_i}{\rho}, \quad i=1,\ldots,n-1\end{split}
\end{equation}\begin{equation}\label{equation:combustion:isochoric_T_eqn}
\begin{split}\frac{\partial T}{\partial t} = \frac{\rho_\mathrm{in}}{\rho \tau c_v}\sum_{i=1}^{n}Y_{i,\mathrm{in}}(e_{i,\mathrm{in}} - e_i) - \frac{1}{\rho c_v}\sum_{i=1}^{n}\omega_i e_i + \frac{1}{\rho c_v}\frac{A}{V}\left(h(T_\infty - T) + \varepsilon\sigma(T_\mathrm{surf}^4 - T^4)\right),\end{split}
\end{equation}

\subsection{Isobaric Reactors}
\label{\detokenize{combustion:isobaric-reactors}}
Figure \hyperref[\detokenize{combustion:figure-isobaric-reactor-diagram}]{Fig.\@ \ref{\detokenize{combustion:figure-isobaric-reactor-diagram}}} diagrams an open, constant-pressure reactor with diathermal walls.
The pressure, \(p\), of this reactor is held constant by the motion of a weightless, frictionless piston.
The expansion work done by this process is an important difference between isobaric and isochoric reactors.
We solve the following equations governing isobaric reactors.
\(c_p\) is the specific, isobaric heat capacity of the mixture,
and \(h_i\) and \(h_{i,\mathrm{in}}\) are the specific internal enthalpy of species \(i\) in the feed and reactor.
\begin{equation}\label{equation:combustion:isobaric_Yi_eqn}
\begin{split}\frac{\partial Y_i}{\partial t} = \frac{Y_{i,\mathrm{in}} - Y_i}{\tau} + \frac{\omega_i}{\rho}, \quad i=1,\ldots,n-1\end{split}
\end{equation}\begin{equation}\label{equation:combustion:isobaric_T_eqn}
\begin{split}\frac{\partial T}{\partial t} = \frac{1}{\tau c_p}\sum_{i=1}^{n}Y_{i,\mathrm{in}}(h_{i,\mathrm{in}} - h_i) - \frac{1}{\rho c_p}\sum_{i=1}^{n}\omega_i h_i + \frac{1}{\rho c_p}\frac{A}{V}\left(h(T_\infty - T) + \varepsilon\sigma(T_\mathrm{surf}^4 - T^4)\right),\end{split}
\end{equation}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=660\sphinxpxdimen]{{isobaric-reactor-diagram}.png}
\caption{Isobaric reactor with expansion work, mass transfer, and convective and radiative heat transfer}\label{\detokenize{combustion:id14}}\label{\detokenize{combustion:figure-isobaric-reactor-diagram}}\end{figure}


\section{Governing Equations for Non-premixed Flamelets}
\label{\detokenize{combustion:governing-equations-for-non-premixed-flamelets}}
The unsteady flamelet equations describe the evolution of mass fractions \(Y_i\) and temperature \(T\)
in a Lagrangian time \(t\) and the mixture fraction \(\mathcal{Z}\).
Equations (\ref{equation:combustion:adiabatic_flamelet_Yi_eqn}) and (\ref{equation:combustion:adiabatic_flamelet_T_eqn}) govern adiabatic flamelets,
which evolve due to diffusion (with strength proportional the scalar dissipation rate \(\chi\)) and chemistry.
These equations do not account for differential diffusion, which is currently not supported in Spitfire.
The term in the temperature equation with single derivatives in \(\mathcal{Z}\) is not seen in all flamelet
equations as it requires careful derivation.
This term models enthalpy diffusion and is optional in Spitfire (specify \sphinxcode{\sphinxupquote{include\_enthalpy\_flux=True}} when building a flamelet object).
Steady flamelets are derived from these equations by simply removing the time term, which leaves the steady flamelet equations
that define the diffusive-reactive balance presumed in the ensemble of thin laminar flames in a turbulent flame (in the flamelet modeling approach).
\begin{equation}\label{equation:combustion:adiabatic_flamelet_Yi_eqn}
\begin{split}\frac{\partial Y_i}{\partial t} = \frac{\chi}{2}\frac{\partial^2 Y_i}{\partial \mathcal{Z}^2} + \frac{\omega_i}{\rho},\end{split}
\end{equation}\begin{equation}\label{equation:combustion:adiabatic_flamelet_T_eqn}
\begin{split}\frac{\partial T}{\partial t} = \frac{\chi}{2}\left(\frac{\partial^2 T}{\partial \mathcal{Z}^2} + \frac{\partial T}{\partial \mathcal{Z}}\sum_{i=1}^{n}\frac{c_{p,i}}{c_p}\frac{\partial Y_i}{\partial \mathcal{Z}}\right) - \frac{1}{\rho c_p}\sum_{i=1}^{n}\omega_i h_i.\end{split}
\end{equation}
These equations are supplemented by boundary conditions defined by the oxidizer and fuel states,
\begin{equation}\label{equation:combustion:combustion:0}
\begin{split}T(t, 0) &= T_{\mathrm{oxy}}, \\
Y_i(t, 0) &= Y_{i,\mathrm{oxy}}, \\
T(t, 1) &= T_{\mathrm{fuel}}, \\
Y_i(t, 1) &= Y_{i,\mathrm{fuel}}.\end{split}
\end{equation}
The dissipation rate \(\chi\) can be a constant or depend on the mixture fraction as
\begin{equation}\label{equation:combustion:combustion:1}
\begin{split}\chi(\mathcal{Z}) = \chi_{\mathrm{max}} \exp\left( -2\left[\mathrm{erfinv}(2\mathcal{Z}-1)\right]^2 \right).\end{split}
\end{equation}
Spitfire also supports nonadiabatic flamelets, which modifies only the temperature equation,
\begin{equation}\label{equation:combustion:nonadiabatic_flamelet_T_eqn}
\begin{split}\frac{\partial T}{\partial t} = \left.\frac{\partial T}{\partial t}\right|_{\mathrm{adiabatic}} + \frac{1}{\rho c_p}\left(h(T_\infty - T) + \varepsilon\sigma(T_\mathrm{surf}^4 - T^4)\right).\end{split}
\end{equation}
Spitfire allows the convection and radiation coefficients and temperatures to vary over the mixture fraction.
A special option for building transient heat loss flamelet libraries involves the following choices
(enabled with \sphinxcode{\sphinxupquote{use\_scaled\_heat\_loss=True}}).
\begin{equation}\label{equation:combustion:combustion:2}
\begin{split}T_\infty &= T_\mathrm{oxy} + \mathcal{Z}(T_\mathrm{fuel} - T_\mathrm{oxy}), \\
h &= h' \chi_{\mathrm{max}} \frac{1 - \mathcal{Z}_{\mathrm{st}} }{ \mathcal{Z}_{\mathrm{st}} }, \\
\varepsilon &= 0,\end{split}
\end{equation}
where \(\mathcal{Z}_{\mathrm{st}}\) is the stoichiometric mixture fraction and
\(h'\) is an arbitrary parameter of order \(10^7\) to drive a flamelet to extinction due to heat loss.


\section{Chemical Kinetic Models}
\label{\detokenize{combustion:chemical-kinetic-models}}
Spitfire currently supports various forms of reaction rate expressions for homogeneous gas-phase systems.
Let \(n_r\) be the number of elementary reactions.
The net mass production rate of species \(i\) is then
\begin{equation}\label{equation:combustion:combustion:3}
\begin{split}\omega_i = M_i \sum_{j=1}^{n_r}\nu_{i,j}q_j,\end{split}
\end{equation}
where \(\nu_{i,j}\) is the net molar stoichiometric coefficient of species \(i\) in reaction \(j\) and \(q_j\) is the rate of progress of reaction \(j\).

The rate of progress is decomposed into two parts: first, the mass action component \(\mathcal{R}_j\), and second, the TBAF component \(\mathcal{C}_j\) which contains third-body enhancement and falloff effects.
\begin{equation}\label{equation:combustion:combustion:4}
\begin{split}q_j = \overset{\text{mass action}}{\mathcal{R}_j}\cdot\overset{\text{3-body + falloff}}{\mathcal{C}_j}.\end{split}
\end{equation}
The mass action component consists of forward and reverse rate constants \(k_{f,j}\) and \(k_{r,j}\) along with products of species concentrations \(\left\langle c_k\right\rangle\),
\begin{equation}\label{equation:combustion:combustion:5}
\begin{split}\mathcal{R}_j = k_{f,j}\prod_{k=1}^{N}\left\langle c_k\right\rangle^{\nu^f_{k,j}} - k_{r,j}\prod_{k=1}^{N}\left\langle c_k\right\rangle^{\nu^r_{k,j}},\end{split}
\end{equation}
in which \(\nu^f_{i,j}\) and \(\nu^r_{i,j}\) are the forward and reverse stoichiometric coefficients of species \(i\) in reaction \(j\), respectively.

The forward rate constant is found with a modified Arrhenius expression,
\begin{equation}\label{equation:combustion:combustion:6}
\begin{split}k_{f,j} = A_j T^{b_j} \exp\left(-\frac{E_{a,j}}{R_u T}\right) = A_j T^{b_j} \exp\left(-\frac{T_{a,j}}{T}\right),\end{split}
\end{equation}
where \(A_j\), \(b_j\), and \(E_{a,j}\) are the pre-exponential factor, temperature exponent, and activation energy of reaction \(j\), respectively.
We define \(T_{a,j}=E_{a,j}/R_u\) as the {\color{red}\bfseries{}{}`}activation temperature.’

The reverse rate constant of an irreversible reaction is zero.
\(k_{r,j}\) for a reversible reaction is found with the equilibrium constant \(K_{c,j}\), via \(k_{r,j} = k_{f,j}/K_{c,j}\).
The equilibrium constant is
\begin{equation}\label{equation:combustion:combustion:7}
\begin{split}K_{c,j} = \left(\frac{p_\text{atm}}{R_u}\right)^{\Xi_j}\exp\left(\sum_{k=1}^{N}\nu_{k,j}B_k\right),\end{split}
\end{equation}
where \(\Xi_j=\sum_{k=1}^{N}\nu_{k,j}\) and \(B_k\) is
\begin{equation}\label{equation:combustion:combustion:8}
\begin{split}B_k = -\ln(T) + \frac{M_k}{R_u}\left(s_k - \frac{h_k}{T}\right).\end{split}
\end{equation}
For the TBAF component \(\mathcal{C}_j\) there are two nontrivial cases: (1) a three-body reaction and, (2) a unimolecular/recombination falloff reaction.
If a reaction is not of a three-body or falloff type, then \(\mathcal{C}_j = 1\).
For three-body reactions, it is
\begin{equation}\label{equation:combustion:combustion:9}
\begin{split}\mathcal{C}_j = \left\langle c_{TB,j}\right\rangle = \sum_{i=1}^{N}\alpha_{i,j}\left\langle c_i\right\rangle,\end{split}
\end{equation}
where \(\alpha_{i,j}\) is the third-body enhancement factor of species \(i\) in reaction \(j\), and \(\left\langle c_{TB,j}\right\rangle\) is the third-body-enhanced concentration of reaction \(j\).
The quantity \(\alpha_{i,j}\) defaults to one if not specified.
For falloff reactions, the TBAF component is
\begin{equation}\label{equation:combustion:combustion:10}
\begin{split}\mathcal{C}_j = \frac{p_{fr,j}}{1 + p_{fr,j}}\mathcal{F}_j,\end{split}
\end{equation}
in which \(p_{fr,j}\) and \(\mathcal{F}_j\) are the falloff reduced pressure and falloff blending factor, respectively.
The falloff reduced pressure is
\begin{equation}\label{equation:combustion:combustion:11}
\begin{split}p_{fr,j} = \frac{k_{0,j}}{k_{f,j}}\mathcal{T}_{F,j},\end{split}
\end{equation}
where \(k_{0,j}\) is the low-pressure limit rate constant evaluated with low-pressure Arrhenius parameters \(A_{0,j}\), \(b_{0,j}\), \(E_{a,0,j}\), and \(\mathcal{T}_{F,j}\) is the {\color{red}\bfseries{}{}`}concentration’ of the mixture
which is either that of a single species if specified or the third-body-enhanced concentration if not.

The falloff blending factor \(\mathcal{F}_j\) depends upon the specified falloff form.
For the Lindemann approach, \(\mathcal{F}_j = 1\).
In the Troe form,
\begin{equation}\label{equation:combustion:combustion:12}
\begin{split}\mathcal{F}_j &= \mathcal{F}_{\text{cent}}^{1/(1+(A/B)^2)}, \\
\mathcal{F}_{\text{cent}} &= (1-a_{\text{Troe}})\exp\left(-\frac{T}{T^{***}}\right) + a_{\text{Troe}}\exp\left(-\frac{T}{T^{*}}\right) + \exp\left(-\frac{T^{**}}{T}\right), \\
A &= \log_{10}p_{FR,j} - 0.67\log_{10}\mathcal{F}_{\text{cent}} - 0.4, \\
B &= 0.806 - 1.1762\log_{10}\mathcal{F}_{\text{cent}} - 0.14\log_{10}p_{FR,j},\end{split}
\end{equation}
where \(a_{\text{Troe}}\), \(T^{*}\), \(T^{**}\), and \(T^{***}\) are specified parameters of the Troe form.
If \(T^{***}\) is unspecified in the mechanism file then its term is ignored.


\section{Species Thermodynamics}
\label{\detokenize{combustion:species-thermodynamics}}
Spitfire supports thermodynamics (enthalpies, entropies, equilibrium coefficients, etc.) based on two models of
species heat capacities.
First is a species with a constant heat capacity:
\begin{equation}\label{equation:combustion:combustion:13}
\begin{split}c_{p,i} &= c_{p,i}^\circ, \\
h_i &= h_i^\circ + c_{p,i}^\circ(T - T^\circ), \\
s_i &= s_i^\circ + c_{p,i}^\circ\ln\left(\frac{T}{T^\circ}\right),\end{split}
\end{equation}
where \(h_i^\circ\) and \(s_i^\circ\) are the standard state enthalpy and entropy of formation.

Second is a species with a variable heat capacity determined by the NASA-7 polynomials:
\begin{equation}\label{equation:combustion:combustion:14}
\begin{split}c_{p,i} &= \frac{R_u}{M_i}\left(a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4\right), \\
h_i &= \frac{R_u}{M_i}\left(a_0T + \frac{a_1}{2}T^2 + \frac{a_2}{3}T^3 + \frac{a_3}{4}T^4 + \frac{a_4}{5}T^5 + a_5\right), \\
s_i &= \frac{R_u}{M_i}\left(a_0\ln(T) + a_1T + \frac{a_2}{2}T^2 + \frac{a_3}{3}T^3 + \frac{a_4}{4}T^4 + a_6\right),\end{split}
\end{equation}
where \(a_i\) are the coefficients of the polynomial (in a particular temperature range) and \(R_u\) is the universal molar gas constant.


\chapter{spitfire}
\label{\detokenize{modules:spitfire}}\label{\detokenize{modules::doc}}

\section{spitfire package}
\label{\detokenize{spitfire:spitfire-package}}\label{\detokenize{spitfire::doc}}

\subsection{Subpackages}
\label{\detokenize{spitfire:subpackages}}

\subsubsection{spitfire.chemistry package}
\label{\detokenize{spitfire.chemistry:spitfire-chemistry-package}}\label{\detokenize{spitfire.chemistry::doc}}

\paragraph{Submodules}
\label{\detokenize{spitfire.chemistry:submodules}}

\subparagraph{spitfire.chemistry.flamelet module}
\label{\detokenize{spitfire.chemistry.flamelet:module-spitfire.chemistry.flamelet}}\label{\detokenize{spitfire.chemistry.flamelet:spitfire-chemistry-flamelet-module}}\label{\detokenize{spitfire.chemistry.flamelet::doc}}\index{spitfire.chemistry.flamelet (module)@\spxentry{spitfire.chemistry.flamelet}\spxextra{module}}
This module contains the Flamelet class that provides a high-level interface for nonpremixed flamelets
\index{Flamelet (class in spitfire.chemistry.flamelet)@\spxentry{Flamelet}\spxextra{class in spitfire.chemistry.flamelet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.chemistry.flamelet.}}\sphinxbfcode{\sphinxupquote{Flamelet}}}{\emph{mech\_spec}, \emph{initial\_condition}, \emph{pressure}, \emph{oxy\_stream}, \emph{fuel\_stream}, \emph{max\_dissipation\_rate=None}, \emph{stoich\_dissipation\_rate=None}, \emph{dissipation\_rate=None}, \emph{dissipation\_rate\_form='Peters'}, \emph{lewis\_numbers=None}, \emph{grid=None}, \emph{grid\_points=None}, \emph{grid\_type='clustered'}, \emph{grid\_cluster\_intensity=4.0}, \emph{grid\_cluster\_point='stoichiometric'}, \emph{heat\_transfer='adiabatic'}, \emph{convection\_temperature=None}, \emph{radiation\_temperature=None}, \emph{convection\_coefficient=None}, \emph{radiative\_emissivity=None}, \emph{rates\_sensitivity\_type='exact'}, \emph{sensitivity\_transform\_type='exact'}, \emph{include\_enthalpy\_flux=False}, \emph{include\_variable\_cp=False}, \emph{use\_scaled\_heat\_loss=False}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A class for solving one-dimensional non-premixed flamelets

\sphinxstylestrong{Constructor}: specify boundary streams, mixing rates, etc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{mech\_spec}}] \leavevmode{[}spitfire.chemistry.mechanism.ChemicalMechanismSpec instance{]}
the mechanism

\item[{\sphinxstylestrong{initial\_condition}}] \leavevmode{[}str or np.ndarray{]}
the initial state of the flamelet, either ‘equilibrium’, ‘unreacted’, ‘linear-TY’, or a state vector from another flamelet

\item[{\sphinxstylestrong{pressure}}] \leavevmode{[}float{]}
the pressure of the flamelet

\item[{\sphinxstylestrong{oxy\_stream}}] \leavevmode{[}Cantera.Quantity (a Spitfire stream) or Cantera.gas object{]}
the oxidizer stream

\item[{\sphinxstylestrong{fuel\_stream}}] \leavevmode{[}Cantera.Quantity (a Spitfire stream) or Cantera.gas object{]}
the fuel stream

\item[{\sphinxstylestrong{max\_dissipation\_rate}}] \leavevmode{[}float{]}
the maximum dissipation rate

\item[{\sphinxstylestrong{dissipation\_rate}}] \leavevmode{[}np.ndarray{]}
the dissipation rate over mixture fraction

\item[{\sphinxstylestrong{dissipation\_rate\_form}}] \leavevmode{[}str{]}
the form of dissipation rate to use if the maximum value is specified (‘Peters’ (default) or ‘constant’)

\item[{\sphinxstylestrong{lewis\_numbers}}] \leavevmode{[}np.ndarray{]}
the Lewis numbers - do not use at the moment, as the nonunity Le formulation does not currently have consistent enthalpy fluxes

\item[{\sphinxstylestrong{grid}}] \leavevmode{[}np.ndarray{]}
the location of the grid points (specifying the grid directly invalidates other grid arguments)

\item[{\sphinxstylestrong{grid\_points}}] \leavevmode{[}int{]}
the number of grid points to use if Spitfire is to build the grid (if the grid argument is not specified, this is required)

\item[{\sphinxstylestrong{grid\_type}}] \leavevmode{[}str{]}
the type of grid, either ‘clustered’ (default) or ‘uniform’

\item[{\sphinxstylestrong{grid\_cluster\_intensity}}] \leavevmode{[}float{]}
how tightly clustered grid points will be around the grid\_cluster\_point if grid\_type is ‘clustered’ (default: 4)

\item[{\sphinxstylestrong{grid\_cluster\_point}}] \leavevmode{[}float{]}
the location of grid point clustering (default is the stoichiometric mixture fraction)

\item[{\sphinxstylestrong{heat\_transfer}}] \leavevmode{[}str{]}
whether or not the flamelet is ‘adiabatic’ or ‘nonadiabatic’

\item[{\sphinxstylestrong{convection\_temperature}}] \leavevmode{[}float{]}
the convective heat loss reference temperature

\item[{\sphinxstylestrong{radiation\_temperature}}] \leavevmode{[}float{]}
the radiation heat loss reference temperature

\item[{\sphinxstylestrong{convection\_coefficient}}] \leavevmode{[}float{]}
the convective heat loss coefficient

\item[{\sphinxstylestrong{radiative\_emissivity}}] \leavevmode{[}float{]}
the radiative heat loss coefficient

\item[{\sphinxstylestrong{use\_scaled\_heat\_loss}}] \leavevmode{[}bool{]}
whether or not to use a special form of reference temperature and coefficients for heat loss

\item[{\sphinxstylestrong{include\_enthalpy\_flux}}] \leavevmode{[}bool{]}
whether or not to use a consistent formulation of the enthalpy flux (True) or the simplest flamelet formulation (False)

\item[{\sphinxstylestrong{include\_variable\_cp}}] \leavevmode{[}bool{]}
whether or not to include variation of the heat capacity (True) or use the simplest flamelet formulation (False)

\item[{\sphinxstylestrong{rates\_sensitivity\_type}}] \leavevmode{[}str{]}
how the chemical source term Jacobian is formed, either ‘exact’ or ‘no-TBAF’ which ignores third-body and falloff sensitivities

\item[{\sphinxstylestrong{sensitivity\_transform\_type}}] \leavevmode{[}str{]}
how the Jacobian is transformed, currently only ‘exact’ is supported

\end{description}

\end{description}\end{quote}
\index{check\_ignition\_delay() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{check\_ignition\_delay()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.check_ignition_delay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_ignition\_delay}}}{\emph{state}}{}~
\end{fulllineitems}

\index{compute\_ignition\_delay() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{compute\_ignition\_delay()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.compute_ignition_delay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_ignition\_delay}}}{\emph{delta\_temperature\_ignition=None}, \emph{minimum\_allowable\_residual=1e-12}, \emph{**kwargs}}{}
Integrate in time until ignition (exceeding a specified threshold of the increase in temperature)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta\_temperature\_ignition}}] \leavevmode{[}float{]}
how much the temperature of the reactor must have increased for ignition to have occurred, default is 400 K

\item[{\sphinxstylestrong{minimum\_allowable\_residual}}] \leavevmode{[}float{]}
how small the residual can be before the reactor is deemed to ‘never’ ignite, default is 1.e-12

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{max\_time\_step}}] \leavevmode{[}float{]}
The maximum time step allowed by the integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{nonlinear\_solve\_tolerance}}] \leavevmode{[}float{]}
tolerance for the nonlinear solver

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use - only ‘block thomas’ (default, heavily recommended) or ‘superlu’ are supported

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{the ignition delay of the reactor, in seconds}}] \leavevmode
\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_steady\_state() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{compute\_steady\_state()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.compute_steady_state}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_steady\_state}}}{\emph{tolerance=1e-06}, \emph{verbose=False}}{}
Solve for the steady state of this flamelet, using a number of numerical algorithms

This will first try Newton’s method, which is fast if it manages to converge.
If Newton’s method fails, the pseudo-transient continuation (psitc) method is used.
Finally, if both Newton’s method and psitc fail, ESDIRK64 time integration with adaptive stepping is attempted.

This is meant to be a convenient interface for common usage.
If it fails, try utilizing each of the steady solvers on their own with special parameters specified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{tolerance}}] \leavevmode{[}float{]}
residual tolerance below which the solution has converged

\item[{\sphinxstylestrong{verbose}}] \leavevmode{[}bool{]}
whether or not to write out status and failure messages

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{dissipation\_rate (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{dissipation\_rate}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.dissipation_rate}}\pysigline{\sphinxbfcode{\sphinxupquote{dissipation\_rate}}}~
\end{fulllineitems}

\index{final\_interior\_state (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{final\_interior\_state}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.final_interior_state}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_interior\_state}}}~
\end{fulllineitems}

\index{final\_mass\_fraction() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{final\_mass\_fraction()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.final_mass_fraction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{final\_mass\_fraction}}}{\emph{key}}{}~
\end{fulllineitems}

\index{final\_state (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{final\_state}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.final_state}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_state}}}~
\end{fulllineitems}

\index{final\_temperature (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{final\_temperature}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.final_temperature}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_temperature}}}~
\end{fulllineitems}

\index{fuel\_state (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{fuel\_state}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.fuel_state}}\pysigline{\sphinxbfcode{\sphinxupquote{fuel\_state}}}~
\end{fulllineitems}

\index{fuel\_stream (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{fuel\_stream}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.fuel_stream}}\pysigline{\sphinxbfcode{\sphinxupquote{fuel\_stream}}}~
\end{fulllineitems}

\index{initial\_interior\_state (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{initial\_interior\_state}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.initial_interior_state}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_interior\_state}}}~
\end{fulllineitems}

\index{initial\_mass\_fraction() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{initial\_mass\_fraction()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.initial_mass_fraction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{initial\_mass\_fraction}}}{\emph{key}}{}~
\end{fulllineitems}

\index{initial\_state (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{initial\_state}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.initial_state}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_state}}}~
\end{fulllineitems}

\index{initial\_temperature (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{initial\_temperature}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.initial_temperature}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_temperature}}}~
\end{fulllineitems}

\index{insitu\_process\_cantera\_method() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{insitu\_process\_cantera\_method()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.insitu_process_cantera_method}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insitu\_process\_cantera\_method}}}{\emph{label}, \emph{method=None}, \emph{index=None}}{}
Add a general cantera function as an in situ processor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{label}}] \leavevmode{[}str{]}
the label of the computed result (also the cantera method to compute if the method parameter is not given)

\item[{\sphinxstylestrong{method}}] \leavevmode{[}str{]}
the cantera method to evaluate

\item[{\sphinxstylestrong{index}}] \leavevmode{[}str or int{]}
the integer index or species name of the vector element of interest, if the cantera function returns a vector

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{insitu\_process\_cema() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{insitu\_process\_cema()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.insitu_process_cema}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insitu\_process\_cema}}}{\emph{explosion\_indices=False}, \emph{participation\_indices=False}, \emph{secondary\_mode=False}}{}
Turn on chemical explosive mode analysis, at least computing the explosive eigenvalue
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{explosion\_indices}}] \leavevmode{[}bool{]}
whether or not to compute variable explosion indices

\item[{\sphinxstylestrong{participation\_indices}}] \leavevmode{[}bool{]}
whether or not to compute reaction participation indices

\item[{\sphinxstylestrong{secondary\_mode}}] \leavevmode{[}bool{]}
whether or not to compute the secondary explosive eigenvalue and (if specified already) its associated explosion/participation indices

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{insitu\_process\_quantity() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{insitu\_process\_quantity()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.insitu_process_quantity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insitu\_process\_quantity}}}{\emph{key}}{}
Specify that a quantity be processed in situ.
\begin{quote}

Available keys: ‘temperature’, ‘density’, ‘pressure’, ‘energy’, ‘enthalpy’, ‘heat capacity cv’, ‘heat capacity cp’,
‘mass fractions’, ‘mole fractions’, ‘production rates’, ‘heat release rate’

If a key is not in this list then cantera will be used.
This will cause a failure if cantera can not compute the requested quantity.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{key}}] \leavevmode{[}str{]}
the quantity to process

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{integrate()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.integrate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate}}}{\emph{termination}, \emph{first\_time\_step=1e-06}, \emph{max\_time\_step=0.001}, \emph{minimum\_time\_step\_count=40}, \emph{transient\_tolerance=1e-10}, \emph{write\_log=False}, \emph{log\_rate=100}, \emph{maximum\_steps\_per\_jacobian=1}, \emph{nonlinear\_solve\_tolerance=1e-12}, \emph{linear\_solver='block thomas'}, \emph{stepper\_type=\textless{}class 'spitfire.time.methods.ESDIRK64'\textgreater{}}, \emph{nlsolver\_type=\textless{}class 'spitfire.time.nonlinear.SimpleNewtonSolver'\textgreater{}}, \emph{stepcontrol\_type=\textless{}class 'spitfire.time.stepcontrol.PIController'\textgreater{}}, \emph{extra\_governor\_args=\{\}}, \emph{extra\_stepper\_args=\{\}}, \emph{extra\_nlsolver\_args=\{\}}, \emph{extra\_stepcontrol\_args=\{\}}}{}
Base method for flamelet integration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{termination}}] \leavevmode{[}Termination object as in spitfire.time.governor{]}
how integration is stopped - instead of calling integrate() directly, use the integrate\_to\_time(), integrate\_to\_steady(), etc. methods of this class

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{max\_time\_step}}] \leavevmode{[}float{]}
The maximum time step allowed by the integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{nonlinear\_solve\_tolerance}}] \leavevmode{[}float{]}
tolerance for the nonlinear solver

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use - only ‘block thomas’ (default, heavily recommended) or ‘superlu’ are supported

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_for\_heat\_loss() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{integrate\_for\_heat\_loss()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.integrate_for_heat_loss}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_for\_heat\_loss}}}{\emph{temperature\_tolerance=0.05}, \emph{steady\_tolerance=0.0001}, \emph{**kwargs}}{}~\begin{description}
\item[{Integrate a flamelet until the temperature profile is sufficiently linear.}] \leavevmode
This is used to generate the heat loss dimension for flamelet libraries.
Note that this will terminate the integration if a steady state is identified,
which may simply indicate that the heat transfer settings were insufficient to
drive the temperature to a linear enough profile.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{temperature\_tolerance}}] \leavevmode{[}float{]}
tolerance for termination, where max(T) \textless{}= (1 + tolerance) max(T\_oxy, T\_fuel)

\item[{\sphinxstylestrong{steady\_tolerance}}] \leavevmode{[}float{]}
residual tolerance below which steady state is defined

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{max\_time\_step}}] \leavevmode{[}float{]}
The maximum time step allowed by the integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{nonlinear\_solve\_tolerance}}] \leavevmode{[}float{]}
tolerance for the nonlinear solver

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use - only ‘block thomas’ (default, heavily recommended) or ‘superlu’ are supported

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_steady() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{integrate\_to\_steady()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.integrate_to_steady}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_steady}}}{\emph{steady\_tolerance=0.0001}, \emph{**kwargs}}{}
Integrate a flamelet until steady state is reached
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{steady\_tolerance}}] \leavevmode{[}float{]}
residual tolerance below which steady state is defined

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{max\_time\_step}}] \leavevmode{[}float{]}
The maximum time step allowed by the integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{nonlinear\_solve\_tolerance}}] \leavevmode{[}float{]}
tolerance for the nonlinear solver

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use - only ‘block thomas’ (default, heavily recommended) or ‘superlu’ are supported

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_steady\_after\_ignition() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{integrate\_to\_steady\_after\_ignition()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.integrate_to_steady_after_ignition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_steady\_after\_ignition}}}{\emph{steady\_tolerance=0.0001}, \emph{delta\_temperature\_ignition=400.0}, \emph{**kwargs}}{}~\begin{description}
\item[{Integrate a flamelet until steady state is reached after ignition (based on temperature) has occurred.}] \leavevmode
This is helpful in slowly-evolving systems whose initial residual may be lower than the prescribed tolerance.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{steady\_tolerance}}] \leavevmode{[}float{]}
residual tolerance below which steady state is defined

\item[{\sphinxstylestrong{delta\_temperature\_ignition}}] \leavevmode{[}float{]}
how much the temperature of the reactor must have increased for ignition to have occurred, default is 400 K

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{max\_time\_step}}] \leavevmode{[}float{]}
The maximum time step allowed by the integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{nonlinear\_solve\_tolerance}}] \leavevmode{[}float{]}
tolerance for the nonlinear solver

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use - only ‘block thomas’ (default, heavily recommended) or ‘superlu’ are supported

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_time() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{integrate\_to\_time()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.integrate_to_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_time}}}{\emph{final\_time}, \emph{**kwargs}}{}
Integrate a flamelet until it reaches a specified simulation time
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{final\_time}}] \leavevmode{[}float{]}
time at which integration ceases

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{max\_time\_step}}] \leavevmode{[}float{]}
The maximum time step allowed by the integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{nonlinear\_solve\_tolerance}}] \leavevmode{[}float{]}
tolerance for the nonlinear solver

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use - only ‘block thomas’ (default, heavily recommended) or ‘superlu’ are supported

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{iteration\_count (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{iteration\_count}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.iteration_count}}\pysigline{\sphinxbfcode{\sphinxupquote{iteration\_count}}}~
\end{fulllineitems}

\index{linear\_temperature (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{linear\_temperature}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.linear_temperature}}\pysigline{\sphinxbfcode{\sphinxupquote{linear\_temperature}}}
Get the linear temperature profile

\end{fulllineitems}

\index{mechanism (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{mechanism}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.mechanism}}\pysigline{\sphinxbfcode{\sphinxupquote{mechanism}}}~
\end{fulllineitems}

\index{mixfrac\_grid (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{mixfrac\_grid}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.mixfrac_grid}}\pysigline{\sphinxbfcode{\sphinxupquote{mixfrac\_grid}}}~
\end{fulllineitems}

\index{oxy\_state (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{oxy\_state}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.oxy_state}}\pysigline{\sphinxbfcode{\sphinxupquote{oxy\_state}}}~
\end{fulllineitems}

\index{oxy\_stream (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{oxy\_stream}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.oxy_stream}}\pysigline{\sphinxbfcode{\sphinxupquote{oxy\_stream}}}~
\end{fulllineitems}

\index{pressure (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{pressure}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.pressure}}\pysigline{\sphinxbfcode{\sphinxupquote{pressure}}}~
\end{fulllineitems}

\index{process\_quantities\_on\_state() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{process\_quantities\_on\_state()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.process_quantities_on_state}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_quantities\_on\_state}}}{\emph{state}, \emph{quantities=None}}{}
Compute the specified in situ quantities on a given flamelet state.
This will return a dictionary that maps each quantity’s name to its computed values for the state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{state}}] \leavevmode{[}np.ndarray{]}
the flamelet state - get this from a Flamelet object

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{solution\_times (spitfire.chemistry.flamelet.Flamelet attribute)@\spxentry{solution\_times}\spxextra{spitfire.chemistry.flamelet.Flamelet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.solution_times}}\pysigline{\sphinxbfcode{\sphinxupquote{solution\_times}}}
Obtain this reactor’s integration times

\end{fulllineitems}

\index{state\_with\_bcs() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{state\_with\_bcs()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.state_with_bcs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{state\_with\_bcs}}}{\emph{state}}{}~
\end{fulllineitems}

\index{steady\_solve\_newton() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{steady\_solve\_newton()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.steady_solve_newton}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{steady\_solve\_newton}}}{\emph{initial\_guess=None}, \emph{tolerance=1e-06}, \emph{max\_iterations=10}, \emph{max\_factor\_line\_search=1.5}, \emph{max\_allowed\_residual=1000000.0}, \emph{min\_allowable\_state\_var=-1e-06}, \emph{norm\_order=inf}, \emph{log\_rate=100000}, \emph{verbose=True}}{}~\begin{description}
\item[{Use Newton’s method to solve for the steady state of this flamelet.}] \leavevmode
Note that Newton’s method is unlikely to converge unless an accurate initial guess is given.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{initial\_guess}}] \leavevmode{[}np.ndarray{]}
the initial guess - obtain this from a Flamelet

\item[{\sphinxstylestrong{tolerance}}] \leavevmode{[}float{]}
residual tolerance below which the solution has converged

\item[{\sphinxstylestrong{max\_iterations}}] \leavevmode{[}int{]}
maximum number of iterations before failure is detected

\item[{\sphinxstylestrong{max\_factor\_line\_search}}] \leavevmode{[}float{]}
the maximum factor by which the residual is allowed to increase in the line search algorithm

\item[{\sphinxstylestrong{max\_allowed\_residual}}] \leavevmode{[}float{]}
the maximum allowable value of the residual

\item[{\sphinxstylestrong{min\_allowable\_state\_var}}] \leavevmode{[}float{]}
the lowest value (negative or zero) that a state variable can take during the solution process

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in measuring the residual

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often a message about the solution status is written

\item[{\sphinxstylestrong{verbose}}] \leavevmode{[}bool{]}
whether to write out the solver status (log messages) or write out failure descriptions

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{steady\_solve\_psitc() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{steady\_solve\_psitc()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.steady_solve_psitc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{steady\_solve\_psitc}}}{\emph{initial\_guess=None}, \emph{tolerance=1e-06}, \emph{max\_iterations=400}, \emph{min\_allowable\_state\_var=-1e-06}, \emph{ds\_init=1.0}, \emph{ds\_init\_decrease=4.0}, \emph{adaptive\_restart=True}, \emph{diffusion\_factor=4.0}, \emph{global\_ds=False}, \emph{ds\_safety=0.1}, \emph{ds\_ramp=1.1}, \emph{ds\_max=10000.0}, \emph{max\_factor\_line\_search=1.5}, \emph{max\_allowed\_residual=1000000.0}, \emph{log\_rate=100000}, \emph{norm\_order=inf}, \emph{\_recursion\_depth=0}, \emph{max\_recursion\_depth=20}, \emph{verbose=True}}{}
Use an adaptive pseudotransient continuation method to compute the steady state of this flamelet
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{initial\_guess}}] \leavevmode{[}np.ndarray{]}
the initial guess - obtain this from a Flamelet

\item[{\sphinxstylestrong{tolerance}}] \leavevmode{[}float{]}
residual tolerance below which the solution has converged

\item[{\sphinxstylestrong{max\_iterations}}] \leavevmode{[}int{]}
maximum number of iterations before failure is detected

\item[{\sphinxstylestrong{max\_factor\_line\_search}}] \leavevmode{[}float{]}
the maximum factor by which the residual is allowed to increase in the line search algorithm

\item[{\sphinxstylestrong{max\_allowed\_residual}}] \leavevmode{[}float{]}
the maximum allowable value of the residual

\item[{\sphinxstylestrong{min\_allowable\_state\_var}}] \leavevmode{[}float{]}
the lowest value (negative or zero) that a state variable can take during the solution process

\item[{\sphinxstylestrong{ds\_init}}] \leavevmode{[}float{]}
the initial pseudo time step (default: 1.), decrease to 1e-1 or 1e-2 for more robustness

\item[{\sphinxstylestrong{ds\_init\_decrease}}] \leavevmode{[}float{]}
how the initial dual time step is decreased upon failure if adaptive\_restart is used (default: 4)

\item[{\sphinxstylestrong{adaptive\_restart}}] \leavevmode{[}bool{]}
whether or not the solver restarts with decreased ds\_init upon failure (default: True)

\item[{\sphinxstylestrong{diffusion\_factor}}] \leavevmode{[}float{]}
how strongly diffusion is weighted in the pseudo time step adaptation (default: 4) (expert parameter)

\item[{\sphinxstylestrong{global\_ds}}] \leavevmode{[}bool{]}
whether or not to use a global pseudo time step (default: False) (setting to True not recommended)

\item[{\sphinxstylestrong{ds\_safety}}] \leavevmode{[}float{]}
the ‘safety factor’ in the pseudo time step adaptation (default: 0.1), increase for speed, decrease for robustness

\item[{\sphinxstylestrong{ds\_ramp}}] \leavevmode{[}float{]}
how quickly the pseudo time step is allowed to increase (default: 1.1), increase for speed, decrease for robustness

\item[{\sphinxstylestrong{ds\_max}}] \leavevmode{[}flaot{]}
maximum allowable value of the pseudo time step (default: 1.e4)

\item[{\sphinxstylestrong{max\_recursion\_depth}}] \leavevmode{[}int{]}
how many adaptive restarts may be attempted

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in measuring the residual

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often a message about the solution status is written

\item[{\sphinxstylestrong{verbose}}] \leavevmode{[}bool{]}
whether to write out the solver status (log messages) or write out failure descriptions

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{temporary\_alc\_in\_chi\_max() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{temporary\_alc\_in\_chi\_max()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.temporary_alc_in_chi_max}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{temporary\_alc\_in\_chi\_max}}}{}{}~
\end{fulllineitems}

\index{trajectory\_data() (spitfire.chemistry.flamelet.Flamelet method)@\spxentry{trajectory\_data()}\spxextra{spitfire.chemistry.flamelet.Flamelet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.Flamelet.trajectory_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{trajectory\_data}}}{\emph{key}}{}
Obtain the simulation data associated with a particular key/label (processed in situ)

\end{fulllineitems}


\end{fulllineitems}

\index{build\_adiabatic\_slfm\_table() (in module spitfire.chemistry.flamelet)@\spxentry{build\_adiabatic\_slfm\_table()}\spxextra{in module spitfire.chemistry.flamelet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.build_adiabatic_slfm_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{spitfire.chemistry.flamelet.}}\sphinxbfcode{\sphinxupquote{build\_adiabatic\_slfm\_table}}}{\emph{flamelet\_specs}, \emph{tabulated\_quantities}, \emph{lower\_chimax=0.1}, \emph{upper\_chimax=None}, \emph{n\_chimax=40}, \emph{chimax\_vec=None}, \emph{extinction\_limit\_fraction=0.5}, \emph{verbose=True}, \emph{solver\_verbose=False}}{}
Build an adiabatic steady laminar flamelet library, tabulating quantities over the mixture fraction and dissipation rate

This method will use a quick, rough estimate of the steady extinction limit to establish dissipation rate bounds,
unless they are explicitly provided by the user.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{flamelet\_specs}}] \leavevmode{[}dict{]}
a dictionary of arguments for building Flamelet objects

\item[{\sphinxstylestrong{tabulated\_quantities}}] \leavevmode{[}list{[}str{]}{]}
quantities to compute over the table

\item[{\sphinxstylestrong{lower\_chimax}}] \leavevmode{[}float{]}
the lower bound of the maximum dissipation rate in the table (default: 0.1)

\item[{\sphinxstylestrong{upper\_chimax}}] \leavevmode{[}float{]}
the upper bound of the maximum dissipation rate in the table (default: specified by a guess at the extinction limit)

\item[{\sphinxstylestrong{n\_chimax}}] \leavevmode{[}int{]}
the number of maximum dissipation rates to employ in the table

\item[{\sphinxstylestrong{extinction\_limit\_fraction}}] \leavevmode{[}float{]}
the fraction of the steady extinction limit to use as the maximum dissipation rate, if upper\_chimax is not specified

\item[{\sphinxstylestrong{verbose}}] \leavevmode{[}bool{]}
whether or not to write out status messages of the table generation

\item[{\sphinxstylestrong{solver\_verbose}}] \leavevmode{[}bool{]}
whether or not to write out status and failure messages of the solvers driving the table

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_nonadiabatic\_gamma\_slfm\_table() (in module spitfire.chemistry.flamelet)@\spxentry{build\_nonadiabatic\_gamma\_slfm\_table()}\spxextra{in module spitfire.chemistry.flamelet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.build_nonadiabatic_gamma_slfm_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{spitfire.chemistry.flamelet.}}\sphinxbfcode{\sphinxupquote{build\_nonadiabatic\_gamma\_slfm\_table}}}{\emph{flamelet\_specs}, \emph{tabulated\_quantities}, \emph{lower\_chimax=0.1}, \emph{upper\_chimax=None}, \emph{n\_chimax=40}, \emph{chimax\_vec=None}, \emph{extinction\_limit\_fraction=0.5}, \emph{verbose=True}, \emph{solver\_verbose=False}, \emph{h\_stoich\_spacing=20000.0}, \emph{num\_procs=1}}{}~
\end{fulllineitems}

\index{build\_structured\_nonadiabatic\_gamma\_slfm\_table() (in module spitfire.chemistry.flamelet)@\spxentry{build\_structured\_nonadiabatic\_gamma\_slfm\_table()}\spxextra{in module spitfire.chemistry.flamelet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.build_structured_nonadiabatic_gamma_slfm_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{spitfire.chemistry.flamelet.}}\sphinxbfcode{\sphinxupquote{build\_structured\_nonadiabatic\_gamma\_slfm\_table}}}{\emph{*args}, \emph{**kwargs}}{}~
\end{fulllineitems}

\index{expand\_enthalpy\_defect\_dimension() (in module spitfire.chemistry.flamelet)@\spxentry{expand\_enthalpy\_defect\_dimension()}\spxextra{in module spitfire.chemistry.flamelet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.expand_enthalpy_defect_dimension}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{spitfire.chemistry.flamelet.}}\sphinxbfcode{\sphinxupquote{expand\_enthalpy\_defect\_dimension}}}{\emph{args}}{}~
\end{fulllineitems}

\index{interpolate\_to\_structured\_gamma\_dimension() (in module spitfire.chemistry.flamelet)@\spxentry{interpolate\_to\_structured\_gamma\_dimension()}\spxextra{in module spitfire.chemistry.flamelet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.flamelet:spitfire.chemistry.flamelet.interpolate_to_structured_gamma_dimension}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{spitfire.chemistry.flamelet.}}\sphinxbfcode{\sphinxupquote{interpolate\_to\_structured\_gamma\_dimension}}}{\emph{unstructured\_table}, \emph{verbose=False}}{}~
\end{fulllineitems}



\subparagraph{spitfire.chemistry.general\_diff\_rxn module}
\label{\detokenize{spitfire.chemistry.general_diff_rxn:module-spitfire.chemistry.general_diff_rxn}}\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire-chemistry-general-diff-rxn-module}}\label{\detokenize{spitfire.chemistry.general_diff_rxn::doc}}\index{spitfire.chemistry.general\_diff\_rxn (module)@\spxentry{spitfire.chemistry.general\_diff\_rxn}\spxextra{module}}
Copyright (c) 2018-2019 Michael Alan Hansen - All Rights Reserved
You may use, distribute and modify this code under the terms of the MIT license.

You should have received a copy of the MIT license with this file.
If not, please write to \sphinxhref{mailto:mahanse@sandia.gov}{mahanse@sandia.gov} or \sphinxhref{mailto:mike.hansen@chemeng.utah.edu}{mike.hansen@chemeng.utah.edu}
\index{DiffusionReaction1D\_FiniteDifference (class in spitfire.chemistry.general\_diff\_rxn)@\spxentry{DiffusionReaction1D\_FiniteDifference}\spxextra{class in spitfire.chemistry.general\_diff\_rxn}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.chemistry.general\_diff\_rxn.}}\sphinxbfcode{\sphinxupquote{DiffusionReaction1D\_FiniteDifference}}}{\emph{initial\_conditions}, \emph{diffusion\_coefficient}, \emph{source\_term}, \emph{source\_term\_jacobian=None}, \emph{left\_boundary\_state=None}, \emph{right\_boundary\_state=None}, \emph{lewis\_numbers=None}, \emph{variable\_names=None}, \emph{grid=None}, \emph{grid\_points=None}, \emph{grid\_type='uniform'}, \emph{grid\_cluster\_intensity=2.0}, \emph{grid\_cluster\_point=0.5}}{}
Bases: \sphinxcode{\sphinxupquote{object}}
\index{diffusion\_coefficient (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute)@\spxentry{diffusion\_coefficient}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.diffusion_coefficient}}\pysigline{\sphinxbfcode{\sphinxupquote{diffusion\_coefficient}}}~
\end{fulllineitems}

\index{final\_state (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute)@\spxentry{final\_state}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.final_state}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_state}}}~
\end{fulllineitems}

\index{grid (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute)@\spxentry{grid}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.grid}}\pysigline{\sphinxbfcode{\sphinxupquote{grid}}}~
\end{fulllineitems}

\index{initial\_state (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute)@\spxentry{initial\_state}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.initial_state}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_state}}}~
\end{fulllineitems}

\index{integrate() (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method)@\spxentry{integrate()}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.integrate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate}}}{\emph{termination}, \emph{time\_method='implicit-esdirk64'}, \emph{time\_step='adaptive'}, \emph{first\_time\_step=1e-06}, \emph{max\_time\_step=1.0}, \emph{minimum\_time\_step\_count=40}, \emph{transient\_tolerance=1e-10}, \emph{write\_log=False}, \emph{log\_rate=100}, \emph{maximum\_steps\_per\_jacobian=1}, \emph{linear\_solve\_tolerance=1e-15}, \emph{nonlinear\_solve\_tolerance=1e-12}, \emph{linear\_solver='superlu'}}{}
Base method for flamelet integration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{termination}}] \leavevmode{[}Termination object as in spitfire.time.governor{]}
how integration is stopped - instead of calling integrate() directly, use the integrate\_to\_time(), integrate\_to\_steady(), etc. methods of this class

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use, at the moment either ‘lapack’ (dense, direct) or ‘superlu’ (sparse, direct) are available

\item[{\sphinxstylestrong{plot}}] \leavevmode{[}list{]}
List of variables (temperature and/or specific species names) to be plotted after the time integration completes.
No plot is shown if a list is not provided.
Temperature is plotted in the first subplot if any list of variables is provided for plotting (even if temperature is not specified in the list of variables).
Species mass fractions will be plotted in a second subplot if any species names are provided in the list of variables.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_steady() (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method)@\spxentry{integrate\_to\_steady()}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.integrate_to_steady}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_steady}}}{\emph{steady\_tolerance=0.0001}, \emph{**kwargs}}{}
Integrate a flamelet until steady state is reached
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{steady\_tolerance}}] \leavevmode{[}float{]}
residual tolerance below which steady state is defined

\item[{\sphinxstylestrong{**kwargs}}] \leavevmode
Arbitrary keyword arguments - see the integrate() method documentation

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_time() (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method)@\spxentry{integrate\_to\_time()}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.integrate_to_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_time}}}{\emph{final\_time}, \emph{**kwargs}}{}
Integrate a flamelet until it reaches a specified simulation time
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{final\_time}}] \leavevmode{[}float{]}
time at which integration ceases

\item[{\sphinxstylestrong{**kwargs}}] \leavevmode
Arbitrary keyword arguments - see the integrate() method documentation

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{solution\_times (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute)@\spxentry{solution\_times}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.solution_times}}\pysigline{\sphinxbfcode{\sphinxupquote{solution\_times}}}
Obtain this reactor’s integration times

\end{fulllineitems}

\index{trajectory\_data() (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method)@\spxentry{trajectory\_data()}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.trajectory_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{trajectory\_data}}}{\emph{key}}{}~
\end{fulllineitems}

\index{variable\_names (spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute)@\spxentry{variable\_names}\spxextra{spitfire.chemistry.general\_diff\_rxn.DiffusionReaction1D\_FiniteDifference attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.general_diff_rxn:spitfire.chemistry.general_diff_rxn.DiffusionReaction1D_FiniteDifference.variable_names}}\pysigline{\sphinxbfcode{\sphinxupquote{variable\_names}}}~
\end{fulllineitems}


\end{fulllineitems}



\subparagraph{spitfire.chemistry.mechanism module}
\label{\detokenize{spitfire.chemistry.mechanism:module-spitfire.chemistry.mechanism}}\label{\detokenize{spitfire.chemistry.mechanism:spitfire-chemistry-mechanism-module}}\label{\detokenize{spitfire.chemistry.mechanism::doc}}\index{spitfire.chemistry.mechanism (module)@\spxentry{spitfire.chemistry.mechanism}\spxextra{module}}
This module facilitates loading chemical reaction mechanisms in Cantera format and mixing streams in useful ways.
\index{ChemicalMechanismSpec (class in spitfire.chemistry.mechanism)@\spxentry{ChemicalMechanismSpec}\spxextra{class in spitfire.chemistry.mechanism}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.chemistry.mechanism.}}\sphinxbfcode{\sphinxupquote{ChemicalMechanismSpec}}}{\emph{cantera\_xml}, \emph{group\_name}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A class that loads chemical mechanisms and mixes streams.

This class facilitates some simple way of specifying the fuel and oxidizer streams for flamelets
and of blending these streams to make mixtures for zero-dimensional simulations.

\sphinxstylestrong{Constructor}: specify a chemical mechanism in cantera XML format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{cantera\_xml}}] \leavevmode{[}str{]}
a cantera XML file describing the thermochemistry and (optionally) transport properties

\item[{\sphinxstylestrong{group\_name}}] \leavevmode{[}str{]}
the phase to use (e.g. a phase with transport properties vs without, if such a split exists in the XML file)

\end{description}

\end{description}\end{quote}
\index{copy\_stream() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{copy\_stream()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.copy_stream}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy\_stream}}}{\emph{stream}}{}
Make a duplicate of a stream - use this to avoid inadvertently modifying a stream by reference.

\end{fulllineitems}

\index{copy\_streams() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{copy\_streams()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.copy_streams}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy\_streams}}}{\emph{streams}}{}
Make a copy of a list of streams, returning a list with copies of each stream.

\end{fulllineitems}

\index{gas (spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute)@\spxentry{gas}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.gas}}\pysigline{\sphinxbfcode{\sphinxupquote{gas}}}
Obtain this mechanism’s cantera Solution object

\end{fulllineitems}

\index{griffon (spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute)@\spxentry{griffon}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.griffon}}\pysigline{\sphinxbfcode{\sphinxupquote{griffon}}}
Obtain this mechanism’s griffon PyCombustionKernels object

\end{fulllineitems}

\index{group\_name (spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute)@\spxentry{group\_name}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.group_name}}\pysigline{\sphinxbfcode{\sphinxupquote{group\_name}}}
Obtain the group name of the identified mechanism’s XML specification

\end{fulllineitems}

\index{mech\_xml\_path (spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute)@\spxentry{mech\_xml\_path}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.mech_xml_path}}\pysigline{\sphinxbfcode{\sphinxupquote{mech\_xml\_path}}}
Obtain the path of the identified mechanism’s XML specification

\end{fulllineitems}

\index{mix\_for\_equivalence\_ratio() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{mix\_for\_equivalence\_ratio()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.mix_for_equivalence_ratio}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mix\_for\_equivalence\_ratio}}}{\emph{phi}, \emph{fuel}, \emph{oxy}}{}
Mix a stream of fuel and oxidizer such that the mixture has a specified equivalence ratio.

\end{fulllineitems}

\index{mix\_for\_normalized\_equivalence\_ratio() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{mix\_for\_normalized\_equivalence\_ratio()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.mix_for_normalized_equivalence_ratio}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mix\_for\_normalized\_equivalence\_ratio}}}{\emph{normalized\_phi}, \emph{fuel}, \emph{oxy}}{}
Mix a stream of fuel and oxidizer such that the mixture has a specified normalized equivalence ratio.

\end{fulllineitems}

\index{mix\_fuels\_for\_stoich\_mixture\_fraction() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{mix\_fuels\_for\_stoich\_mixture\_fraction()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.mix_fuels_for_stoich_mixture_fraction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mix\_fuels\_for\_stoich\_mixture\_fraction}}}{\emph{fuel1}, \emph{fuel2}, \emph{zstoich}, \emph{oxy}}{}
Mix two fuel streams for a specified stoichiometric mixture fraction given a particular oxidizer.
As an example, this can be used to dilute a fuel with Nitrogen to hit a particular stoichiometric mixture fraction.

Note that it is not possible to reach all stoichiometric mixture fractions with any fuel combinations!
In such a case this function will throw an error.

\end{fulllineitems}

\index{mix\_streams() (spitfire.chemistry.mechanism.ChemicalMechanismSpec static method)@\spxentry{mix\_streams()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.mix_streams}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{mix\_streams}}}{\emph{streams}, \emph{basis}, \emph{constant='HP'}}{}
Mix a number of streams by mass/mole and at constant HP, TP, UV, etc. (as supported by Cantera)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{streams}} \textendash{} a list of tuples as {[}(stream, amount){]} where amount is the mass/moles (depending on the basis)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basis}} \textendash{} whether amounts are masses or moles

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{constant}} \textendash{} property pair held constant, such as HP, TP, UV - any combination supported by Cantera

\end{itemize}

\item[{Returns}] \leavevmode
the requested mixture

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_reactions (spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute)@\spxentry{n\_reactions}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.n_reactions}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_reactions}}}
Obtain the number of reactions in this chemical mechanism

\end{fulllineitems}

\index{n\_species (spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute)@\spxentry{n\_species}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.n_species}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_species}}}
Obtain the number of species in this chemical mechanism

\end{fulllineitems}

\index{species\_index() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{species\_index()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.species_index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{species\_index}}}{\emph{name}}{}
Obtain the index of a particular species

\end{fulllineitems}

\index{species\_names (spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute)@\spxentry{species\_names}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.species_names}}\pysigline{\sphinxbfcode{\sphinxupquote{species\_names}}}
Obtain the names of speciesin this chemical mechanism

\end{fulllineitems}

\index{stoich\_mass\_fuel\_to\_oxy\_ratio() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{stoich\_mass\_fuel\_to\_oxy\_ratio()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.stoich_mass_fuel_to_oxy_ratio}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stoich\_mass\_fuel\_to\_oxy\_ratio}}}{\emph{fuel\_stream}, \emph{oxy\_stream}}{}
Get the mass ratio of fuel to oxidizer at stoichiometric conditions.
Assumes C, O, and H combustion of single fuel and single oxidizer streams.

\end{fulllineitems}

\index{stoich\_mixture\_fraction() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{stoich\_mixture\_fraction()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.stoich_mixture_fraction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stoich\_mixture\_fraction}}}{\emph{fuel\_stream}, \emph{oxy\_stream}}{}
Get the mixture fraction at stoichiometric conditions.
Assumes C, O, and H combustion of single fuel and single oxidizer streams.

\end{fulllineitems}

\index{stoich\_molar\_fuel\_to\_oxy\_ratio() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{stoich\_molar\_fuel\_to\_oxy\_ratio()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.stoich_molar_fuel_to_oxy_ratio}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stoich\_molar\_fuel\_to\_oxy\_ratio}}}{\emph{fuel\_stream}, \emph{oxy\_stream}}{}
Get the molar ratio of fuel to oxidizer at stoichiometric conditions.
Assumes C, O, and H combustion of single fuel and single oxidizer streams.

\end{fulllineitems}

\index{stream() (spitfire.chemistry.mechanism.ChemicalMechanismSpec method)@\spxentry{stream()}\spxextra{spitfire.chemistry.mechanism.ChemicalMechanismSpec method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.mechanism:spitfire.chemistry.mechanism.ChemicalMechanismSpec.stream}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stream}}}{\emph{properties=None}, \emph{values=None}, \emph{stp\_air=False}}{}
Build a mixture of species with certain properties
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{properties}} \textendash{} a string of keys used in building a cantera Quantity (e.g., ‘TPX’ or ‘TP’ or ‘X’, etc.)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{values}} \textendash{} the values of the properties

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stp\_air}} \textendash{} special option to make a stream of air at standard temperature and pressure
This produces a stream of 3.74 mol N2 per mole O2 at 300 K and one atmosphere

\end{itemize}

\item[{Returns}] \leavevmode
a cantera Quantity object with the specified properties

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{spitfire.chemistry.reactors module}
\label{\detokenize{spitfire.chemistry.reactors:module-spitfire.chemistry.reactors}}\label{\detokenize{spitfire.chemistry.reactors:spitfire-chemistry-reactors-module}}\label{\detokenize{spitfire.chemistry.reactors::doc}}\index{spitfire.chemistry.reactors (module)@\spxentry{spitfire.chemistry.reactors}\spxextra{module}}
This module contains the HomogeneousReactor class that provides a high-level interface for 0-D reactors
\index{HomogeneousReactor (class in spitfire.chemistry.reactors)@\spxentry{HomogeneousReactor}\spxextra{class in spitfire.chemistry.reactors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.chemistry.reactors.}}\sphinxbfcode{\sphinxupquote{HomogeneousReactor}}}{\emph{mech\_spec}, \emph{initial\_mixture}, \emph{configuration}, \emph{heat\_transfer}, \emph{mass\_transfer}, \emph{convection\_temperature=None}, \emph{radiation\_temperature=None}, \emph{convection\_coefficient=None}, \emph{radiative\_emissivity=None}, \emph{shape\_dimension\_dict=None}, \emph{mixing\_tau=None}, \emph{feed\_temperature=None}, \emph{feed\_mass\_fractions=None}, \emph{feed\_density=None}, \emph{rates\_sensitivity\_type='exact'}, \emph{sensitivity\_transform\_type='exact'}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A class for solving zero-dimensional reactors

\sphinxstylestrong{Constructor}: specify a mechanism, initial mixture, reactor specifications, and thermochemical property evaluation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{mech\_spec}}] \leavevmode{[}spitfire.chemistry.mechanism.ChemicalMechanismSpec instance{]}
the mechanism

\item[{\sphinxstylestrong{initial\_mixture}}] \leavevmode{[}Cantera.Quantity (a Spitfire stream) or Cantera.gas object{]}
the initial mixture of the reactor

\item[{\sphinxstylestrong{configuration}}] \leavevmode{[}str{]}
whether the reactor is constant-volume (isochoric) or constant-pressure (isobaric)

\item[{\sphinxstylestrong{heat\_transfer}}] \leavevmode{[}str{]}
whether the reactor is adiabatic, isothermal, or diathermal (finite-rate heat transfer by convection and/or radiation)

\item[{\sphinxstylestrong{mass\_transfer}}] \leavevmode{[}str{]}
whether the reactor is closed or open

\item[{\sphinxstylestrong{convection\_temperature}}] \leavevmode{[}float or callable{]}
the temperature of external fluid in a diathermal reactor, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{radiation\_temperature}}] \leavevmode{[}float or callable{]}
the temperature of external radiation body of a diathermal reactor, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{convection\_coefficient}}] \leavevmode{[}float or callable{]}
the convection coefficient, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{radiative\_emissivity}}] \leavevmode{[}float or callable{]}
the radiative emissivity, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{shape\_dimension\_dict}}] \leavevmode{[}float or callable{]}
The shape and dimension of a diathermal reactor. The shape is one of ‘cube’, ‘sphere’, ‘capsule’, ‘tetrahedron’, ‘octahedron’, or ‘icosahedron’
(see \sphinxhref{https://en.wikipedia.org/wiki/Surface-area-to-volume\_ratio\#Mathematical\_examples}{wikipedia}).
The dimension is either the characteristic length (‘char. length’) in meters or volume (‘volume’) in cubic meters.

\item[{\sphinxstylestrong{mixing\_tau}}] \leavevmode{[}float or callable{]}
The mixing time of an open reactor, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{feed\_temperature}}] \leavevmode{[}float or callable{]}
the temperature of the feed stream of an open reactor, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{feed\_mass\_fractions}}] \leavevmode{[}np.array or callable{]}
the mass fractions of the feed stream of an open reactor, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{feed\_density}}] \leavevmode{[}float or callable{]}
the density of the feed stream of an open reactor, either a constant or a function of time, f(t)

\item[{\sphinxstylestrong{rates\_sensitivity\_type}}] \leavevmode{[}str{]}
how the chemical source term Jacobian is formed, either ‘exact’ or ‘no-TBAF’ which ignores third-body and falloff sensitivities

\item[{\sphinxstylestrong{sensitivity\_transform\_type}}] \leavevmode{[}str{]}
how the Jacobian is transformed for isobaric systems, currently only ‘exact’ is supported

\end{description}

\end{description}\end{quote}
\index{compute\_ignition\_delay() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{compute\_ignition\_delay()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.compute_ignition_delay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_ignition\_delay}}}{\emph{delta\_temperature\_ignition=None}, \emph{minimum\_allowable\_residual=1e-12}, \emph{**kwargs}}{}
Integrate in time until ignition (exceeding a specified threshold of the increase in temperature)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta\_temperature\_ignition}}] \leavevmode{[}float{]}
how much the temperature of the reactor must have increased for ignition to have occurred, default is 400 K

\item[{\sphinxstylestrong{minimum\_allowable\_residual}}] \leavevmode{[}float{]}
how small the residual can be before the reactor is deemed to ‘never’ ignite, default is 1.e-12

\item[{\sphinxstylestrong{**kwargs}}] \leavevmode
Arbitrary keyword arguments - see the integrate() method documentation

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{the ignition delay of the reactor, in seconds}}] \leavevmode
\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_ignition\_delay\_direct\_griffon() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{compute\_ignition\_delay\_direct\_griffon()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.compute_ignition_delay_direct_griffon}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_ignition\_delay\_direct\_griffon}}}{\emph{delta\_temperature\_ignition=400.0}, \emph{minimum\_allowable\_residual=1e-12}, \emph{**kwargs}}{}
Integrate in time until ignition (exceeding a specified threshold of the increase in temperature)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta\_temperature\_ignition}}] \leavevmode{[}float{]}
how much the temperature of the reactor must have increased for ignition to have occurred, default is 400 K

\item[{\sphinxstylestrong{minimum\_allowable\_residual}}] \leavevmode{[}float{]}
how small the residual can be before the reactor is deemed to ‘never’ ignite, default is 1.e-12

\item[{\sphinxstylestrong{**kwargs}}] \leavevmode
Arbitrary keyword arguments - see the integrate() method documentation

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{the ignition delay of the reactor, in seconds}}] \leavevmode
\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{final\_mass\_fractions (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{final\_mass\_fractions}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.final_mass_fractions}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_mass\_fractions}}}
Obtain this reactor’s final mass fractions

\end{fulllineitems}

\index{final\_pressure (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{final\_pressure}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.final_pressure}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_pressure}}}
Obtain this reactor’s final pressure

\end{fulllineitems}

\index{final\_state (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{final\_state}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.final_state}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_state}}}
Obtain this reactor’s final state vector

\end{fulllineitems}

\index{final\_temperature (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{final\_temperature}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.final_temperature}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_temperature}}}
Obtain this reactor’s final temperature

\end{fulllineitems}

\index{gas (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{gas}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.gas}}\pysigline{\sphinxbfcode{\sphinxupquote{gas}}}~
\end{fulllineitems}

\index{get\_supported\_reactor\_shapes() (spitfire.chemistry.reactors.HomogeneousReactor class method)@\spxentry{get\_supported\_reactor\_shapes()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.get_supported_reactor_shapes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{get\_supported\_reactor\_shapes}}}{}{}
Obtain a list of supported reactor geometries

\end{fulllineitems}

\index{ignition\_delay() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{ignition\_delay()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.ignition_delay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ignition\_delay}}}{\emph{delta\_temperature\_ignition=None}}{}
Find the time at which ignition occurred in a pre-run simulation (based on temperature increase)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{delta\_temperature\_ignition}}] \leavevmode{[}float{]}
how much the temperature of the reactor must have increased for ignition to have occurred, default is 400 K

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{the ignition delay of the pre-simulated reactor, in seconds}}] \leavevmode
\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{initial\_explosive\_eigenvalue (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{initial\_explosive\_eigenvalue}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.initial_explosive_eigenvalue}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_explosive\_eigenvalue}}}~
\end{fulllineitems}

\index{initial\_mass\_fractions (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{initial\_mass\_fractions}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.initial_mass_fractions}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_mass\_fractions}}}
Obtain this reactor’s initial mass fractions

\end{fulllineitems}

\index{initial\_pressure (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{initial\_pressure}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.initial_pressure}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_pressure}}}
Obtain this reactor’s initial pressure

\end{fulllineitems}

\index{initial\_state (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{initial\_state}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.initial_state}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_state}}}
Obtain this reactor’s initial state vector

\end{fulllineitems}

\index{initial\_temperature (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{initial\_temperature}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.initial_temperature}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_temperature}}}
Obtain this reactor’s initial temperature

\end{fulllineitems}

\index{insitu\_process\_cantera\_method() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{insitu\_process\_cantera\_method()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.insitu_process_cantera_method}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insitu\_process\_cantera\_method}}}{\emph{label}, \emph{method=None}, \emph{index=None}}{}
Add a general cantera function as an in situ processor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{label}}] \leavevmode{[}str{]}
the label of the computed result (also the cantera method to compute if the method parameter is not given)

\item[{\sphinxstylestrong{method}}] \leavevmode{[}str{]}
the cantera method to evaluate

\item[{\sphinxstylestrong{index}}] \leavevmode{[}str or int{]}
the integer index or species name of the vector element of interest, if the cantera function returns a vector

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{insitu\_process\_cema() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{insitu\_process\_cema()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.insitu_process_cema}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insitu\_process\_cema}}}{\emph{explosion\_indices=False}, \emph{participation\_indices=False}, \emph{secondary\_mode=False}}{}
Turn on chemical explosive mode analysis, at least computing the explosive eigenvalue
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{explosion\_indices}}] \leavevmode{[}bool{]}
whether or not to compute variable explosion indices

\item[{\sphinxstylestrong{participation\_indices}}] \leavevmode{[}bool{]}
whether or not to compute reaction participation indices

\item[{\sphinxstylestrong{secondary\_mode}}] \leavevmode{[}bool{]}
whether or not to compute the secondary explosive eigenvalue and (if specified already) its associated explosion/participation indices

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{insitu\_process\_quantity() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{insitu\_process\_quantity()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.insitu_process_quantity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insitu\_process\_quantity}}}{\emph{key}}{}
Specify that a quantity be processed in situ.
\begin{quote}

Available keys: ‘temperature’, ‘density’, ‘pressure’, ‘energy’, ‘enthalpy’, ‘heat capacity cv’, ‘heat capacity cp’,
‘mass fractions’, ‘mole fractions’, ‘production rates’, ‘heat release rate’, ‘eigenvalues’

If a key is not in this list then cantera will be used.
This will cause a failure if cantera can not compute the requested quantity.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{key}}] \leavevmode{[}str{]}
the quantity to process

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{integrate()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.integrate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate}}}{\emph{termination}, \emph{first\_time\_step=1e-06}, \emph{max\_time\_step=1000000.0}, \emph{minimum\_time\_step\_count=40}, \emph{transient\_tolerance=1e-10}, \emph{write\_log=False}, \emph{log\_rate=100}, \emph{maximum\_steps\_per\_jacobian=1}, \emph{nonlinear\_solve\_tolerance=1e-12}, \emph{linear\_solver='lapack'}, \emph{plot=None}, \emph{stepper\_type=\textless{}class 'spitfire.time.methods.ESDIRK64'\textgreater{}}, \emph{nlsolver\_type=\textless{}class 'spitfire.time.nonlinear.SimpleNewtonSolver'\textgreater{}}, \emph{stepcontrol\_type=\textless{}class 'spitfire.time.stepcontrol.PIController'\textgreater{}}, \emph{extra\_governor\_args=\{\}}, \emph{extra\_stepper\_args=\{\}}, \emph{extra\_nlsolver\_args=\{\}}, \emph{extra\_stepcontrol\_args=\{\}}}{}
Base method for reactor integration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{termination}}] \leavevmode{[}Termination object as in spitfire.time.governor{]}
how integration is stopped - instead of calling integrate() directly, use the integrate\_to\_time(), integrate\_to\_steady(), etc. methods of this class

\item[{\sphinxstylestrong{first\_time\_step}}] \leavevmode{[}float{]}
The time step size initially used by the time integrator

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
The minimum number of time steps to run (helpful for slowly evolving simulations, for instance those with low starting temperatures)

\item[{\sphinxstylestrong{transient\_tolerance}}] \leavevmode{[}float{]}
the target temporal error for transient integration

\item[{\sphinxstylestrong{write\_log}}] \leavevmode{[}bool{]}
whether or not to print integration statistics and status during the simulation

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how often to print log information

\item[{\sphinxstylestrong{maximum\_steps\_per\_jacobian}}] \leavevmode{[}int{]}
maximum number of steps Spitfire allows before the Jacobian must be re-evaluated - keep low for robustness, try to increase for performance on large mechanisms

\item[{\sphinxstylestrong{linear\_solver}}] \leavevmode{[}str{]}
which linear solver to use, at the moment either ‘lapack’ (dense, direct) or ‘superlu’ (sparse, direct) are available

\item[{\sphinxstylestrong{plot}}] \leavevmode{[}list{]}
List of variables (temperature and/or specific species names) to be plotted after the time integration completes.
No plot is shown if a list is not provided.
Temperature is plotted in the first subplot if any list of variables is provided for plotting (even if temperature is not specified in the list of variables).
Species mass fractions will be plotted in a second subplot if any species names are provided in the list of variables.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_steady() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{integrate\_to\_steady()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.integrate_to_steady}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_steady}}}{\emph{steady\_tolerance=0.0001}, \emph{**kwargs}}{}
Integrate a reactor until steady state is reached
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{steady\_tolerance}}] \leavevmode{[}float{]}
residual tolerance below which steady state is defined

\item[{\sphinxstylestrong{**kwargs}}] \leavevmode
Arbitrary keyword arguments - see the integrate() method documentation

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_steady\_after\_ignition() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{integrate\_to\_steady\_after\_ignition()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.integrate_to_steady_after_ignition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_steady\_after\_ignition}}}{\emph{steady\_tolerance=0.0001}, \emph{delta\_temperature\_ignition=400.0}, \emph{**kwargs}}{}~\begin{description}
\item[{Integrate a reactor until steady state is reached after ignition (based on temperature) has occurred.}] \leavevmode
This is helpful in slowly-evolving systems whose initial residual may be lower than the prescribed tolerance.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{steady\_tolerance}}] \leavevmode{[}float{]}
residual tolerance below which steady state is defined

\item[{\sphinxstylestrong{delta\_temperature\_ignition}}] \leavevmode{[}float{]}
how much the temperature of the reactor must have increased for ignition to have occurred, default is 400 K

\item[{\sphinxstylestrong{**kwargs}}] \leavevmode
Arbitrary keyword arguments - see the integrate() method documentation

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{integrate\_to\_steady\_direct\_griffon() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{integrate\_to\_steady\_direct\_griffon()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.integrate_to_steady_direct_griffon}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_steady\_direct\_griffon}}}{\emph{steady\_tolerance=0.0001}, \emph{**kwargs}}{}~
\end{fulllineitems}

\index{integrate\_to\_time() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{integrate\_to\_time()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.integrate_to_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate\_to\_time}}}{\emph{final\_time}, \emph{**kwargs}}{}
Integrate a reactor until it reaches a specified simulation time
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{final\_time}}] \leavevmode{[}float{]}
time at which integration ceases

\item[{\sphinxstylestrong{**kwargs}}] \leavevmode
Arbitrary keyword arguments - see the integrate() method documentation

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_reactions (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{n\_reactions}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.n_reactions}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_reactions}}}~
\end{fulllineitems}

\index{n\_species (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{n\_species}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.n_species}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_species}}}~
\end{fulllineitems}

\index{process\_quantities\_on\_state() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{process\_quantities\_on\_state()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.process_quantities_on_state}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_quantities\_on\_state}}}{\emph{state}}{}
Compute the specified in situ quantities on a given reactor state.
This will return a dictionary that maps each quantity’s name to its computed value for this state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{state}}] \leavevmode{[}np.ndarray, Cantera.Quantity (a Spitfire stream), or Cantera.gas object{]}
the thermochemical state at which quantities will be computed

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{solution\_times (spitfire.chemistry.reactors.HomogeneousReactor attribute)@\spxentry{solution\_times}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.solution_times}}\pysigline{\sphinxbfcode{\sphinxupquote{solution\_times}}}
Obtain this reactor’s integration times

\end{fulllineitems}

\index{temporary\_alc\_in\_tau() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{temporary\_alc\_in\_tau()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.temporary_alc_in_tau}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{temporary\_alc\_in\_tau}}}{\emph{taus}, \emph{temps}}{}~
\end{fulllineitems}

\index{trajectory\_data() (spitfire.chemistry.reactors.HomogeneousReactor method)@\spxentry{trajectory\_data()}\spxextra{spitfire.chemistry.reactors.HomogeneousReactor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.chemistry.reactors:spitfire.chemistry.reactors.HomogeneousReactor.trajectory_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{trajectory\_data}}}{\emph{key}}{}
Obtain the simulation data associated with a particular key/label (processed in situ)

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{spitfire.chemistry:module-spitfire.chemistry}}\label{\detokenize{spitfire.chemistry:module-contents}}\index{spitfire.chemistry (module)@\spxentry{spitfire.chemistry}\spxextra{module}}
This module contains Spitfire’s core functionality for combustion (0-D and 1-D) and diffusion-reaction problems.


\subsubsection{spitfire.time package}
\label{\detokenize{spitfire.time:spitfire-time-package}}\label{\detokenize{spitfire.time::doc}}

\paragraph{Submodules}
\label{\detokenize{spitfire.time:submodules}}

\subparagraph{spitfire.time.governor module}
\label{\detokenize{spitfire.time.governor:module-spitfire.time.governor}}\label{\detokenize{spitfire.time.governor:spitfire-time-governor-module}}\label{\detokenize{spitfire.time.governor::doc}}\index{spitfire.time.governor (module)@\spxentry{spitfire.time.governor}\spxextra{module}}
This module contains the time integration governor abstraction,
which combines time steppers, nonlinear solvers, and step controllers into a generic integration loop
that supports arbitrary in situ processing, logging, termination of the integration loop, and more.
For instance, evaluation of the linear projector (Jacobian/preconditioner evaluation and factorization)
for implicit methods is guided by the Governor class as it can oversee the entire integration.
In many cases the Jacobian/preconditioner can be lagged for several time steps to speed up the integration process substantially.
\index{CustomTermination (class in spitfire.time.governor)@\spxentry{CustomTermination}\spxextra{class in spitfire.time.governor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.CustomTermination}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.governor.}}\sphinxbfcode{\sphinxupquote{CustomTermination}}}{\emph{custom\_rule}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Wrapper class for terminating time integration based on a custom rule, a function f(state, t, nt, residual)
which returns True when time integration should continue.

\end{fulllineitems}

\index{FinalTime (class in spitfire.time.governor)@\spxentry{FinalTime}\spxextra{class in spitfire.time.governor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.FinalTime}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.governor.}}\sphinxbfcode{\sphinxupquote{FinalTime}}}{\emph{final\_time}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Wrapper class for terminating time integration based on a specified final time.

\end{fulllineitems}

\index{Governor (class in spitfire.time.governor)@\spxentry{Governor}\spxextra{class in spitfire.time.governor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.Governor}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.governor.}}\sphinxbfcode{\sphinxupquote{Governor}}}
Bases: \sphinxcode{\sphinxupquote{object}}

The class that drives time integration at a high level.

Objects are built with an empty constructor and then attributes are set directly.
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{do\_logging}}] \leavevmode{[}bool{]}
whether or not to continually write out the integrator status and some statistics (default: True)
(turn this off for best performance)

\item[{\sphinxstylestrong{log\_rate}}] \leavevmode{[}int{]}
how many time steps between new lines in the log (default: 1) (increase for best performance)

\item[{\sphinxstylestrong{lines\_per\_header}}] \leavevmode{[}int{]}
how many log lines are written between rewriting the header (default: 10)

\item[{\sphinxstylestrong{extra\_logger\_log}}] \leavevmode{[}callable{]}
a method of form f(state, current\_time, number\_of\_time\_steps, number\_nonlinear\_iter, number\_linear\_iter)
that adds to the log line (default: None)

\item[{\sphinxstylestrong{extra\_logger\_title\_line1}}] \leavevmode{[}str{]}
the first line to place above the extra\_logger\_log text (default: None)

\item[{\sphinxstylestrong{extra\_logger\_title\_line2}}] \leavevmode{[}str{]}
the second line to place above the extra\_logger\_log text (default: None)

\item[{\sphinxstylestrong{projector\_setup\_rate}}] \leavevmode{[}int{]}
the largest number of steps that can occur before setting up the linear projector (default: 1 (every step))

\item[{\sphinxstylestrong{time\_step\_increase\_factor\_to\_force\_jacobian}}] \leavevmode{[}float{]}
how much the time step size must increase on a time step to force setup of the projector (default: 1.05)

\item[{\sphinxstylestrong{time\_step\_decrease\_factor\_to\_force\_jacobian}}] \leavevmode{[}float{]}
how much the time step size must decrease on a time step to force setup of the projector (default: 0.9)

\item[{\sphinxstylestrong{termination\_criteria}}] \leavevmode{[}CustomTermination or FinalTime or Steady or NumberOfTimeSteps{]}
a time termination object (default: None)

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\item[{\sphinxstylestrong{minimum\_time\_step\_count}}] \leavevmode{[}int{]}
minimum number of time steps that can be run (default: 0)

\item[{\sphinxstylestrong{maximum\_time\_step\_count}}] \leavevmode{[}int{]}
maximum number of time steps that can be run (default: Inf)

\item[{\sphinxstylestrong{strict\_temporal\_error\_control}}] \leavevmode{[}bool{]}
whether or not to enforce that error-controlled adaptive time stepping keeps the error estimate below the target (default: False)

\item[{\sphinxstylestrong{nonlinear\_solve\_must\_converge}}] \leavevmode{[}bool{]}
whether or not the nonlinear solver in each time step of implicit methods must converge (default: False)

\item[{\sphinxstylestrong{warn\_on\_failed\_step}}] \leavevmode{[}bool{]}
whether or not to print a warning when a step fails (default: False)

\item[{\sphinxstylestrong{return\_on\_failed\_step}}] \leavevmode{[}bool{]}
whether or not to return and stop integrating when a step fails (default: False)

\item[{\sphinxstylestrong{time\_step\_reduction\_factor\_on\_failure}}] \leavevmode{[}float{]}
factor used in reducing the step size after a step fails, if not returning on failure (default: 0.8)

\item[{\sphinxstylestrong{custom\_update\_checking\_rule}}] \leavevmode{[}callable{]}
method of the form f(state, dstate, time\_error, target\_error, nonlinear\_solve\_converged) that checks validity of a state update (default: None)

\item[{\sphinxstylestrong{time\_step\_reduction\_factor\_on\_slow\_solve}}] \leavevmode{[}float{]}
factor used in reducing the step size after a step is deemed slow by the nonlinear solver (default: 0.8)

\item[{\sphinxstylestrong{clip\_to\_positive}}] \leavevmode{[}bool{]}
whether or not to clip solution values to be nonnegative after each time step (default: False)

\item[{\sphinxstylestrong{custom\_post\_process\_step}}] \leavevmode{[}callable{]}
method of the form f(current\_time, state) that is called after each time step is complete (default: None)

\end{description}

\end{description}\end{quote}
\index{integrate() (spitfire.time.governor.Governor method)@\spxentry{integrate()}\spxextra{spitfire.time.governor.Governor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.Governor.integrate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integrate}}}{\emph{right\_hand\_side=None}, \emph{projector\_setup=None}, \emph{projector\_solve=None}, \emph{initial\_condition=None}, \emph{initial\_time=0.0}, \emph{method=None}, \emph{controller=None}}{}
Run a time integration problem
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{right\_hand\_side}} \textendash{} the right-hand side of the ODE system, in the form f(t, y)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{projector\_setup}} \textendash{} the linear projector setup method, in the form f(y, jacobian\_scale)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{projector\_solve}} \textendash{} the linear projector solve method, in the form f(residual)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_condition}} \textendash{} the initial state vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_time}} \textendash{} the initial time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} \textendash{} the time stepping method (a spitfire.time.methods.TimeStepper object)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{controller}} \textendash{} the time step controller, either a float (for constant time step) or spitfire.time.stepcontrol class

\end{itemize}

\item[{Returns}] \leavevmode
a tuple of time integration statistics (dictionary), final state, final time, and final time step size

\end{description}\end{quote}

\end{fulllineitems}

\index{termination\_criteria (spitfire.time.governor.Governor attribute)@\spxentry{termination\_criteria}\spxextra{spitfire.time.governor.Governor attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.Governor.termination_criteria}}\pysigline{\sphinxbfcode{\sphinxupquote{termination\_criteria}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{NumberOfTimeSteps (class in spitfire.time.governor)@\spxentry{NumberOfTimeSteps}\spxextra{class in spitfire.time.governor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.NumberOfTimeSteps}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.governor.}}\sphinxbfcode{\sphinxupquote{NumberOfTimeSteps}}}{\emph{number\_of\_steps}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Wrapper class for terminating time integration based on the number of time steps taken.

\end{fulllineitems}

\index{SaveAllDataToList (class in spitfire.time.governor)@\spxentry{SaveAllDataToList}\spxextra{class in spitfire.time.governor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.SaveAllDataToList}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.governor.}}\sphinxbfcode{\sphinxupquote{SaveAllDataToList}}}{\emph{initial\_solution}, \emph{initial\_time=0.0}, \emph{save\_frequency=1}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A class that saves solution data and times from time integration at a particular step frequency

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{initial\_time}}] \leavevmode{[}float{]}
the initial time (default: 0.)

\item[{\sphinxstylestrong{initial\_solution}}] \leavevmode{[}np.ndarray{]}
the initial solution

\item[{\sphinxstylestrong{save\_frequency}}] \leavevmode{[}int{]}
how many steps are taken between solution data and times being saved (default: 1.)

\end{description}

\end{description}\end{quote}
\index{reset\_data() (spitfire.time.governor.SaveAllDataToList method)@\spxentry{reset\_data()}\spxextra{spitfire.time.governor.SaveAllDataToList method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.SaveAllDataToList.reset_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_data}}}{\emph{initial\_solution}, \emph{initial\_time=0.0}}{}
Reset the data on a SaveAllDataToList object

\end{fulllineitems}

\index{save\_data() (spitfire.time.governor.SaveAllDataToList method)@\spxentry{save\_data()}\spxextra{spitfire.time.governor.SaveAllDataToList method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.SaveAllDataToList.save_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_data}}}{\emph{t}, \emph{solution}, \emph{*args}, \emph{**kwargs}}{}
Method to provide to the Governor() object as the custom\_post\_process\_step

\end{fulllineitems}

\index{solution\_list (spitfire.time.governor.SaveAllDataToList attribute)@\spxentry{solution\_list}\spxextra{spitfire.time.governor.SaveAllDataToList attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.SaveAllDataToList.solution_list}}\pysigline{\sphinxbfcode{\sphinxupquote{solution\_list}}}
Obtain a np.array of the solutions that were saved

\end{fulllineitems}

\index{t\_list (spitfire.time.governor.SaveAllDataToList attribute)@\spxentry{t\_list}\spxextra{spitfire.time.governor.SaveAllDataToList attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.SaveAllDataToList.t_list}}\pysigline{\sphinxbfcode{\sphinxupquote{t\_list}}}
Obtain a np.array of the list of solution times that were saved

\end{fulllineitems}


\end{fulllineitems}

\index{Steady (class in spitfire.time.governor)@\spxentry{Steady}\spxextra{class in spitfire.time.governor}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.governor:spitfire.time.governor.Steady}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.governor.}}\sphinxbfcode{\sphinxupquote{Steady}}}{\emph{steady\_tolerance}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Wrapper class for terminating time integration based on reaching a steady state (small residual).

\end{fulllineitems}



\subparagraph{spitfire.time.methods module}
\label{\detokenize{spitfire.time.methods:module-spitfire.time.methods}}\label{\detokenize{spitfire.time.methods:spitfire-time-methods-module}}\label{\detokenize{spitfire.time.methods::doc}}\index{spitfire.time.methods (module)@\spxentry{spitfire.time.methods}\spxextra{module}}
This module contains time stepping methods that represent distinct methods of taking a single step in the time integration loop.
Some are explicit, some are implicit.
Some allow adaptive time stepping via control of embedded temporal error estimates while most do not.

Consider a general purpose explicit ODE,
\begin{equation}\label{equation:spitfire.time.methods:spitfire.time.methods:0}
\begin{split}\frac{\partial \boldsymbol{q}}{\partial t} = \boldsymbol{r}(t, \boldsymbol{q}),\end{split}
\end{equation}
where \(\boldsymbol{q}=[q_1,q_2,\ldots]\) is the vector of state variables
and \(\boldsymbol{r}=[r_1,r_2,\ldots]\) is the vector of right-hand side functions.
The classes in this module have a \sphinxcode{\sphinxupquote{single\_step(q, t, h, r, ...)}} method that steps from time level \(t^n\) to
the next time,  \(t^{n+1}=t^n + h\), given a state \(q^n\) and right-hand side function \(r(t,q)\).
For example, the forward Euler method with class \sphinxcode{\sphinxupquote{ForwardEuler}} computes this as \(q^{n+1}=q^n + hr(t^n,q^n)\).

In Spitfire’s unit testing we verify the order of accuracy of most of these methods.
If you add a new one be sure to add it to the unit tester.
See the file: \sphinxcode{\sphinxupquote{test/time/test\_time\_order\_of\_accuracy.py}}.
\index{AdaptiveERK21HeunEuler (class in spitfire.time.methods)@\spxentry{AdaptiveERK21HeunEuler}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveERK21HeunEuler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{AdaptiveERK21HeunEuler}}}{\emph{norm\_weighting=1.0}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.AdaptiveExplicitRungeKutta}}}}}

The second-order Trapezoidal (Heun) method with a first-order Euler method for embedded error estimation
\index{single\_step() (spitfire.time.methods.AdaptiveERK21HeunEuler method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.AdaptiveERK21HeunEuler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveERK21HeunEuler.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{AdaptiveERK54CashKarp (class in spitfire.time.methods)@\spxentry{AdaptiveERK54CashKarp}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveERK54CashKarp}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{AdaptiveERK54CashKarp}}}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.AdaptiveExplicitRungeKutta}}}}}

The fourth-order, five-stage adaptive ERK method of Cash and Karp
\index{single\_step() (spitfire.time.methods.AdaptiveERK54CashKarp method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.AdaptiveERK54CashKarp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveERK54CashKarp.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{AdaptiveExplicitRungeKutta (class in spitfire.time.methods)@\spxentry{AdaptiveExplicitRungeKutta}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{AdaptiveExplicitRungeKutta}}}{\emph{name}, \emph{order}, \emph{error\_order}, \emph{stages}, \emph{norm\_weighting=1.0}, \emph{norm\_order=inf}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ExplicitRungeKutta}}}}}

Base class for explicit Runge-Kutta methods

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{name}}] \leavevmode{[}str{]}
name of the TimeStepper, e.g. ‘Forward Euler’ or ‘Runge Kutta 4’

\item[{\sphinxstylestrong{order}}] \leavevmode{[}int{]}
order of accuracy of the time stepping method

\item[{\sphinxstylestrong{error\_order}}] \leavevmode{[}int{]}
order of accuracy of the embedded error estimation

\item[{\sphinxstylestrong{stages}}] \leavevmode{[}int{]}
number of stages in the Runge-Kutta method

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\end{description}

\end{description}\end{quote}
\index{error\_order (spitfire.time.methods.AdaptiveExplicitRungeKutta attribute)@\spxentry{error\_order}\spxextra{spitfire.time.methods.AdaptiveExplicitRungeKutta attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta.error_order}}\pysigline{\sphinxbfcode{\sphinxupquote{error\_order}}}~
\end{fulllineitems}

\index{norm\_order (spitfire.time.methods.AdaptiveExplicitRungeKutta attribute)@\spxentry{norm\_order}\spxextra{spitfire.time.methods.AdaptiveExplicitRungeKutta attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta.norm_order}}\pysigline{\sphinxbfcode{\sphinxupquote{norm\_order}}}~
\end{fulllineitems}

\index{norm\_weighting (spitfire.time.methods.AdaptiveExplicitRungeKutta attribute)@\spxentry{norm\_weighting}\spxextra{spitfire.time.methods.AdaptiveExplicitRungeKutta attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta.norm_weighting}}\pysigline{\sphinxbfcode{\sphinxupquote{norm\_weighting}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{AdaptiveImplicitTimeStepper (class in spitfire.time.methods)@\spxentry{AdaptiveImplicitTimeStepper}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveImplicitTimeStepper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{AdaptiveImplicitTimeStepper}}}{\emph{name}, \emph{order}, \emph{implicit\_coefficient}, \emph{nonlinear\_solver}, \emph{norm\_weighting=1.0}, \emph{norm\_order=inf}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ImplicitTimeStepper}}}}}

Base class for adaptive implicit time stepper classes

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{name}}] \leavevmode{[}str{]}
name of the TimeStepper

\item[{\sphinxstylestrong{order}}] \leavevmode{[}int{]}
order of accuracy of the time stepping method

\item[{\sphinxstylestrong{implicit\_coefficient}}] \leavevmode{[}float{]}
the leading coefficient used in time-augmented Jacobian matrix assembly

\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\end{description}

\end{description}\end{quote}
\index{implicit\_coefficient (spitfire.time.methods.AdaptiveImplicitTimeStepper attribute)@\spxentry{implicit\_coefficient}\spxextra{spitfire.time.methods.AdaptiveImplicitTimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveImplicitTimeStepper.implicit_coefficient}}\pysigline{\sphinxbfcode{\sphinxupquote{implicit\_coefficient}}}~
\end{fulllineitems}

\index{nonlinear\_solver (spitfire.time.methods.AdaptiveImplicitTimeStepper attribute)@\spxentry{nonlinear\_solver}\spxextra{spitfire.time.methods.AdaptiveImplicitTimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveImplicitTimeStepper.nonlinear_solver}}\pysigline{\sphinxbfcode{\sphinxupquote{nonlinear\_solver}}}~
\end{fulllineitems}

\index{norm\_order (spitfire.time.methods.AdaptiveImplicitTimeStepper attribute)@\spxentry{norm\_order}\spxextra{spitfire.time.methods.AdaptiveImplicitTimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveImplicitTimeStepper.norm_order}}\pysigline{\sphinxbfcode{\sphinxupquote{norm\_order}}}~
\end{fulllineitems}

\index{norm\_weighting (spitfire.time.methods.AdaptiveImplicitTimeStepper attribute)@\spxentry{norm\_weighting}\spxextra{spitfire.time.methods.AdaptiveImplicitTimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveImplicitTimeStepper.norm_weighting}}\pysigline{\sphinxbfcode{\sphinxupquote{norm\_weighting}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{BackwardEuler (class in spitfire.time.methods)@\spxentry{BackwardEuler}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.BackwardEuler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{BackwardEuler}}}{\emph{nonlinear\_solver}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ImplicitTimeStepper}}}}}

The Backward Euler, or implicit Euler, or BDF-1, method

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.BackwardEuler method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.BackwardEuler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.BackwardEuler.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{lhs\_setup}, \emph{lhs\_solve}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{BackwardEulerWithError (class in spitfire.time.methods)@\spxentry{BackwardEulerWithError}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.BackwardEulerWithError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{BackwardEulerWithError}}}{\emph{nonlinear\_solver}, \emph{norm\_weighting=1.0}, \emph{norm\_order=inf}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveImplicitTimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.AdaptiveImplicitTimeStepper}}}}}
\begin{description}
\item[{The Backward Euler, or implicit Euler, or BDF-1, method which uses the nonlinear solver to form an error estimate,}] \leavevmode
allowing adaptivity as in the CVODE code (although without order adaptation - this class is first-order only)

\end{description}

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.BackwardEulerWithError method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.BackwardEulerWithError method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.BackwardEulerWithError.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{lhs\_setup}, \emph{lhs\_solve}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CrankNicolson (class in spitfire.time.methods)@\spxentry{CrankNicolson}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.CrankNicolson}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{CrankNicolson}}}{\emph{nonlinear\_solver}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ImplicitTimeStepper}}}}}

The Crank-Nicolson, or implicit trapezoial, method

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.CrankNicolson method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.CrankNicolson method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.CrankNicolson.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{lhs\_setup}, \emph{lhs\_solve}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ESDIRK64 (class in spitfire.time.methods)@\spxentry{ESDIRK64}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ESDIRK64}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ESDIRK64}}}{\emph{nonlinear\_solver}, \emph{norm\_weighting=1.0}, \emph{norm\_order=inf}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveImplicitTimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.AdaptiveImplicitTimeStepper}}}}}

The six-stage, fourth-order, second-stage-order, explicit singly diagonally implicit method of Kennedy and Carpenter

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.ESDIRK64 method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ESDIRK64 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ESDIRK64.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{lhs\_setup}, \emph{lhs\_solve}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExplicitRungeKutta (class in spitfire.time.methods)@\spxentry{ExplicitRungeKutta}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ExplicitRungeKutta}}}{\emph{name}, \emph{order}, \emph{stages}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.TimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.TimeStepper}}}}}

Base class for explicit Runge-Kutta methods

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{name}}] \leavevmode{[}str{]}
name of the TimeStepper, e.g. ‘Forward Euler’ or ‘Runge Kutta 4’

\item[{\sphinxstylestrong{order}}] \leavevmode{[}int{]}
order of accuracy of the time stepping method

\item[{\sphinxstylestrong{stages}}] \leavevmode{[}int{]}
number of stages in the Runge-Kutta method

\end{description}

\end{description}\end{quote}
\index{stages (spitfire.time.methods.ExplicitRungeKutta attribute)@\spxentry{stages}\spxextra{spitfire.time.methods.ExplicitRungeKutta attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta.stages}}\pysigline{\sphinxbfcode{\sphinxupquote{stages}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{ExplicitRungeKutta2Midpoint (class in spitfire.time.methods)@\spxentry{ExplicitRungeKutta2Midpoint}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta2Midpoint}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ExplicitRungeKutta2Midpoint}}}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ExplicitRungeKutta}}}}}

The explicit Midpoint method
\index{single\_step() (spitfire.time.methods.ExplicitRungeKutta2Midpoint method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ExplicitRungeKutta2Midpoint method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta2Midpoint.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExplicitRungeKutta2Ralston (class in spitfire.time.methods)@\spxentry{ExplicitRungeKutta2Ralston}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta2Ralston}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ExplicitRungeKutta2Ralston}}}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ExplicitRungeKutta}}}}}

The explicit Ralston method, the two-stage, second-order ERK method with lowest principal error norm
\index{single\_step() (spitfire.time.methods.ExplicitRungeKutta2Ralston method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ExplicitRungeKutta2Ralston method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta2Ralston.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExplicitRungeKutta2Trapezoid (class in spitfire.time.methods)@\spxentry{ExplicitRungeKutta2Trapezoid}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta2Trapezoid}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ExplicitRungeKutta2Trapezoid}}}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ExplicitRungeKutta}}}}}

The explicit Trapezoidal method
\index{single\_step() (spitfire.time.methods.ExplicitRungeKutta2Trapezoid method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ExplicitRungeKutta2Trapezoid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta2Trapezoid.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExplicitRungeKutta3Kutta (class in spitfire.time.methods)@\spxentry{ExplicitRungeKutta3Kutta}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta3Kutta}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ExplicitRungeKutta3Kutta}}}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ExplicitRungeKutta}}}}}

Kutta’s three-stage, third-order ERK method
\index{single\_step() (spitfire.time.methods.ExplicitRungeKutta3Kutta method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ExplicitRungeKutta3Kutta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta3Kutta.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ExplicitRungeKutta4Classical (class in spitfire.time.methods)@\spxentry{ExplicitRungeKutta4Classical}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta4Classical}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ExplicitRungeKutta4Classical}}}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ExplicitRungeKutta}}}}}

The classical four-stage, fourth-order ERK method
\index{single\_step() (spitfire.time.methods.ExplicitRungeKutta4Classical method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ExplicitRungeKutta4Classical method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ExplicitRungeKutta4Classical.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ForwardEuler (class in spitfire.time.methods)@\spxentry{ForwardEuler}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ForwardEuler}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ForwardEuler}}}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.TimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.TimeStepper}}}}}

The Forward Euler method
\index{single\_step() (spitfire.time.methods.ForwardEuler method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ForwardEuler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ForwardEuler.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{GeneralAdaptiveExplicitRungeKutta (class in spitfire.time.methods)@\spxentry{GeneralAdaptiveExplicitRungeKutta}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.GeneralAdaptiveExplicitRungeKutta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{GeneralAdaptiveExplicitRungeKutta}}}{\emph{name}, \emph{order}, \emph{A}, \emph{b}, \emph{bhat=None}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.AdaptiveExplicitRungeKutta}}}}}

A general-purpose explicit Runge-Kutta method with embedded error estimation for adaptive time stepping

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{name}}] \leavevmode{[}str{]}
name of the TimeStepper, e.g. ‘Forward Euler’ or ‘Runge Kutta 4’

\item[{\sphinxstylestrong{order}}] \leavevmode{[}int{]}
order of accuracy of the time stepping method

\item[{\sphinxstylestrong{A}}] \leavevmode{[}np.ndarray{]}
Runge-Kutta stage coefficients for the method

\item[{\sphinxstylestrong{b}}] \leavevmode{[}np.ndarray{]}
quadrature coefficients for the method

\item[{\sphinxstylestrong{bhat}}] \leavevmode{[}np.ndarray{]}
embedded error estimation quadrature coefficients (default: None - not adaptive)

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.GeneralAdaptiveExplicitRungeKutta method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.GeneralAdaptiveExplicitRungeKutta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.GeneralAdaptiveExplicitRungeKutta.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{GeneralAdaptiveExplicitRungeKuttaMultipleEmbedded (class in spitfire.time.methods)@\spxentry{GeneralAdaptiveExplicitRungeKuttaMultipleEmbedded}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.GeneralAdaptiveExplicitRungeKuttaMultipleEmbedded}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{GeneralAdaptiveExplicitRungeKuttaMultipleEmbedded}}}{\emph{name}, \emph{order}, \emph{A}, \emph{b}, \emph{bhats}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.AdaptiveExplicitRungeKutta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.AdaptiveExplicitRungeKutta}}}}}

A general-purpose explicit Runge-Kutta method with embedded error estimation for adaptive time stepping

This class is used for advanced adaptive methods that utilize multiple embedded error estimates.

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{name}}] \leavevmode{[}str{]}
name of the TimeStepper, e.g. ‘Forward Euler’ or ‘Runge Kutta 4’

\item[{\sphinxstylestrong{order}}] \leavevmode{[}int{]}
order of accuracy of the time stepping method

\item[{\sphinxstylestrong{A}}] \leavevmode{[}np.ndarray{]}
Runge-Kutta stage coefficients for the method

\item[{\sphinxstylestrong{b}}] \leavevmode{[}np.ndarray{]}
quadrature coefficients for the method

\item[{\sphinxstylestrong{bhats}}] \leavevmode{[}list{[}np.ndarray{]}{]}
list of embedded error estimation quadrature coefficients

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.GeneralAdaptiveExplicitRungeKuttaMultipleEmbedded method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.GeneralAdaptiveExplicitRungeKuttaMultipleEmbedded method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.GeneralAdaptiveExplicitRungeKuttaMultipleEmbedded.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ImplicitMidpoint (class in spitfire.time.methods)@\spxentry{ImplicitMidpoint}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitMidpoint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ImplicitMidpoint}}}{\emph{nonlinear\_solver}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ImplicitTimeStepper}}}}}

The implicit midpoint, or second-order Gauss IRK, method

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.ImplicitMidpoint method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.ImplicitMidpoint method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitMidpoint.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{lhs\_setup}, \emph{lhs\_solve}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ImplicitTimeStepper (class in spitfire.time.methods)@\spxentry{ImplicitTimeStepper}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{ImplicitTimeStepper}}}{\emph{name}, \emph{order}, \emph{implicit\_coefficient}, \emph{nonlinear\_solver}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.TimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.TimeStepper}}}}}

Base class for implicit time stepper classes

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{name}}] \leavevmode{[}str{]}
name of the TimeStepper

\item[{\sphinxstylestrong{order}}] \leavevmode{[}int{]}
order of accuracy of the time stepping method

\item[{\sphinxstylestrong{implicit\_coefficient}}] \leavevmode{[}float{]}
the leading coefficient used in time-augmented Jacobian matrix assembly

\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\end{description}

\end{description}\end{quote}
\index{implicit\_coefficient (spitfire.time.methods.ImplicitTimeStepper attribute)@\spxentry{implicit\_coefficient}\spxextra{spitfire.time.methods.ImplicitTimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper.implicit_coefficient}}\pysigline{\sphinxbfcode{\sphinxupquote{implicit\_coefficient}}}~
\end{fulllineitems}

\index{nonlinear\_solver (spitfire.time.methods.ImplicitTimeStepper attribute)@\spxentry{nonlinear\_solver}\spxextra{spitfire.time.methods.ImplicitTimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper.nonlinear_solver}}\pysigline{\sphinxbfcode{\sphinxupquote{nonlinear\_solver}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{SDIRK22 (class in spitfire.time.methods)@\spxentry{SDIRK22}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.SDIRK22}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{SDIRK22}}}{\emph{nonlinear\_solver}}{}
Bases: {\hyperref[\detokenize{spitfire.time.methods:spitfire.time.methods.ImplicitTimeStepper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.methods.ImplicitTimeStepper}}}}}

A two-stage, second-order singly diagonally implicit method

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{nonlinear\_solver}}] \leavevmode{[}spitfire.time.nonlinear.NonlinearSolver{]}
the solver used in each implicit stage

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\end{description}

\end{description}\end{quote}
\index{single\_step() (spitfire.time.methods.SDIRK22 method)@\spxentry{single\_step()}\spxextra{spitfire.time.methods.SDIRK22 method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.SDIRK22.single_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{single\_step}}}{\emph{state}, \emph{t}, \emph{dt}, \emph{rhs}, \emph{lhs\_setup}, \emph{lhs\_solve}, \emph{*args}, \emph{**kwargs}}{}
Take a single step with this stepper method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the current state

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} the current time

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} \textendash{} the size of the time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhs}} \textendash{} the right-hand side of the ODE in the form f(t, y)

\end{itemize}

\item[{Returns}] \leavevmode
a StepOutput object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StepOutput (class in spitfire.time.methods)@\spxentry{StepOutput}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{StepOutput}}}{\emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Read-only class that holds information about the result of a single time step.

\sphinxstylestrong{Constructor}: build a StepOutput object, specifying all data here (the object will be read-only)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{solution\_update}}] \leavevmode{[}np.ndarray{]}
the update to the solution, the state at the next time level minus that at the current time level

\item[{\sphinxstylestrong{temporal\_error}}] \leavevmode{[}float{]}
the temporal error estimate - for adaptive time stepping through classical error control

\item[{\sphinxstylestrong{nonlinear\_iter}}] \leavevmode{[}int{]}
how many nonlinear iterations the step required - implicit methods only

\item[{\sphinxstylestrong{linear\_iter}}] \leavevmode{[}int{]}
how many linear iterations the step required - implicit methods only

\item[{\sphinxstylestrong{nonlinear\_converged}}] \leavevmode{[}bool{]}
whether or not the nonlinear solver converged - implicit methods only

\item[{\sphinxstylestrong{slow\_nonlinear\_convergence}}] \leavevmode{[}bool{]}
whether or not the nonlinear solver detected slow convergence - implicit methods only

\item[{\sphinxstylestrong{projector\_setups}}] \leavevmode{[}int{]}
the number of times the linear projector was set up (e.g. Jacobian evaluation-factorization)

\item[{\sphinxstylestrong{extra\_errors}}] \leavevmode{[}list{[}float{]}{]}
a list of additional embedded temporal error estimates - for adaptive time stepping through new ratio control

\end{description}

\end{description}\end{quote}
\index{extra\_errors (spitfire.time.methods.StepOutput attribute)@\spxentry{extra\_errors}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.extra_errors}}\pysigline{\sphinxbfcode{\sphinxupquote{extra\_errors}}}~
\end{fulllineitems}

\index{linear\_iter (spitfire.time.methods.StepOutput attribute)@\spxentry{linear\_iter}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.linear_iter}}\pysigline{\sphinxbfcode{\sphinxupquote{linear\_iter}}}~
\end{fulllineitems}

\index{nonlinear\_converged (spitfire.time.methods.StepOutput attribute)@\spxentry{nonlinear\_converged}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.nonlinear_converged}}\pysigline{\sphinxbfcode{\sphinxupquote{nonlinear\_converged}}}~
\end{fulllineitems}

\index{nonlinear\_iter (spitfire.time.methods.StepOutput attribute)@\spxentry{nonlinear\_iter}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.nonlinear_iter}}\pysigline{\sphinxbfcode{\sphinxupquote{nonlinear\_iter}}}~
\end{fulllineitems}

\index{projector\_setups (spitfire.time.methods.StepOutput attribute)@\spxentry{projector\_setups}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.projector_setups}}\pysigline{\sphinxbfcode{\sphinxupquote{projector\_setups}}}~
\end{fulllineitems}

\index{slow\_nonlinear\_convergence (spitfire.time.methods.StepOutput attribute)@\spxentry{slow\_nonlinear\_convergence}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.slow_nonlinear_convergence}}\pysigline{\sphinxbfcode{\sphinxupquote{slow\_nonlinear\_convergence}}}~
\end{fulllineitems}

\index{solution\_update (spitfire.time.methods.StepOutput attribute)@\spxentry{solution\_update}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.solution_update}}\pysigline{\sphinxbfcode{\sphinxupquote{solution\_update}}}~
\end{fulllineitems}

\index{temporal\_error (spitfire.time.methods.StepOutput attribute)@\spxentry{temporal\_error}\spxextra{spitfire.time.methods.StepOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.StepOutput.temporal_error}}\pysigline{\sphinxbfcode{\sphinxupquote{temporal\_error}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{TimeStepper (class in spitfire.time.methods)@\spxentry{TimeStepper}\spxextra{class in spitfire.time.methods}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.TimeStepper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.methods.}}\sphinxbfcode{\sphinxupquote{TimeStepper}}}{\emph{name}, \emph{order}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Base class for time stepper classes

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{name}}] \leavevmode{[}str{]}
name of the TimeStepper, e.g. ‘Forward Euler’ or ‘Runge Kutta 4’

\item[{\sphinxstylestrong{order}}] \leavevmode{[}int{]}
order of accuracy of the time stepping method

\end{description}

\end{description}\end{quote}
\index{name (spitfire.time.methods.TimeStepper attribute)@\spxentry{name}\spxextra{spitfire.time.methods.TimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.TimeStepper.name}}\pysigline{\sphinxbfcode{\sphinxupquote{name}}}~
\end{fulllineitems}

\index{order (spitfire.time.methods.TimeStepper attribute)@\spxentry{order}\spxextra{spitfire.time.methods.TimeStepper attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.methods:spitfire.time.methods.TimeStepper.order}}\pysigline{\sphinxbfcode{\sphinxupquote{order}}}~
\end{fulllineitems}


\end{fulllineitems}



\subparagraph{spitfire.time.nonlinear module}
\label{\detokenize{spitfire.time.nonlinear:module-spitfire.time.nonlinear}}\label{\detokenize{spitfire.time.nonlinear:spitfire-time-nonlinear-module}}\label{\detokenize{spitfire.time.nonlinear::doc}}\index{spitfire.time.nonlinear (module)@\spxentry{spitfire.time.nonlinear}\spxextra{module}}
This module contains nonlinear solvers used in time stepping.
At the moment this is simply Newton’s method.
\index{NonlinearSolver (class in spitfire.time.nonlinear)@\spxentry{NonlinearSolver}\spxextra{class in spitfire.time.nonlinear}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.NonlinearSolver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.nonlinear.}}\sphinxbfcode{\sphinxupquote{NonlinearSolver}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Base class for nonlinear solvers.

\sphinxstylestrong{Constructor}: build a NonlinearSolver object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{max\_nonlinear\_iter}}] \leavevmode{[}int{]}
maximum number of nonlinear iterations to try (default: 20)

\item[{\sphinxstylestrong{slowness\_detection\_iter}}] \leavevmode{[}int{]}
how many iterations the solver runs can run without declaring convergence “slow” (default: Inf)

\item[{\sphinxstylestrong{must\_converge}}] \leavevmode{[}bool{]}
whether or not the solver must converge to a solution within max\_nonlinear\_iter (default: False)

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\item[{\sphinxstylestrong{raise\_naninf}}] \leavevmode{[}bool{]}
whether or not to check for NaN/Inf values in the solution and residual and raise an exception if found (default: False)

\item[{\sphinxstylestrong{custom\_solution\_check}}] \leavevmode{[}callable{]}
a function of the solution that executes custom checks for solution validity (default: None)

\item[{\sphinxstylestrong{setup\_projector\_in\_governor}}] \leavevmode{[}bool{]}
whether or not the linear projector is set up outside of the solver (default: True)

\end{description}

\end{description}\end{quote}
\index{defaults (spitfire.time.nonlinear.NonlinearSolver attribute)@\spxentry{defaults}\spxextra{spitfire.time.nonlinear.NonlinearSolver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.NonlinearSolver.defaults}}\pysigline{\sphinxbfcode{\sphinxupquote{defaults}}\sphinxbfcode{\sphinxupquote{ = \{'custom\_solution\_check': None, 'max\_nonlinear\_iter': 20, 'must\_converge': False, 'norm\_order': inf, 'norm\_weighting': 1.0, 'raise\_naninf': False, 'setup\_projector\_in\_governor': True, 'slowness\_detection\_iter': inf, 'tolerance': 1e-12\}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{SimpleNewtonSolver (class in spitfire.time.nonlinear)@\spxentry{SimpleNewtonSolver}\spxextra{class in spitfire.time.nonlinear}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SimpleNewtonSolver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.nonlinear.}}\sphinxbfcode{\sphinxupquote{SimpleNewtonSolver}}}{\emph{evaluate\_jacobian\_every\_iter=False}, \emph{*args}, \emph{**kwargs}}{}
Bases: {\hyperref[\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.NonlinearSolver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spitfire.time.nonlinear.NonlinearSolver}}}}}

Simple Newton solver

\sphinxstylestrong{Constructor}: build a SimpleNewtonSolver object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{evaluate\_jacobian\_every\_iter}}] \leavevmode{[}bool{]}
whether or not to set up the linear projector on every iteration of Newton’s method (default: False)

\item[{\sphinxstylestrong{max\_nonlinear\_iter}}] \leavevmode{[}int{]}
maximum number of nonlinear iterations to try (default: 20)

\item[{\sphinxstylestrong{slowness\_detection\_iter}}] \leavevmode{[}int{]}
how many iterations the solver runs can run without declaring convergence “slow” (default: Inf)

\item[{\sphinxstylestrong{must\_converge}}] \leavevmode{[}bool{]}
whether or not the solver must converge to a solution within max\_nonlinear\_iter (default: False)

\item[{\sphinxstylestrong{norm\_weighting}}] \leavevmode{[}np.ndarray or float{]}
how the temporal error estimate is weighted in its norm calculation (default: 1)

\item[{\sphinxstylestrong{norm\_order}}] \leavevmode{[}int or np.Inf{]}
the order of the norm used in the temporal error estimate (default: Inf)

\item[{\sphinxstylestrong{raise\_naninf}}] \leavevmode{[}bool{]}
whether or not to check for NaN/Inf values in the solution and residual and raise an exception if found (default: False)

\item[{\sphinxstylestrong{custom\_solution\_check}}] \leavevmode{[}callable{]}
a function of the solution that executes custom checks for solution validity (default: None)

\item[{\sphinxstylestrong{setup\_projector\_in\_governor}}] \leavevmode{[}bool{]}
whether or not the linear projector is set up outside of the solver (default: True)

\end{description}

\end{description}\end{quote}
\index{evaluate\_jacobian\_every\_iter (spitfire.time.nonlinear.SimpleNewtonSolver attribute)@\spxentry{evaluate\_jacobian\_every\_iter}\spxextra{spitfire.time.nonlinear.SimpleNewtonSolver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SimpleNewtonSolver.evaluate_jacobian_every_iter}}\pysigline{\sphinxbfcode{\sphinxupquote{evaluate\_jacobian\_every\_iter}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{SolverOutput (class in spitfire.time.nonlinear)@\spxentry{SolverOutput}\spxextra{class in spitfire.time.nonlinear}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.nonlinear.}}\sphinxbfcode{\sphinxupquote{SolverOutput}}}{\emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Read-only class that holds information about the result of a nonlinear solver.

\sphinxstylestrong{Constructor}: build a SolverOutput object, specifying all data here (the object will be read-only)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{solution}}] \leavevmode{[}np.ndarray{]}
the solution to the nonlinear system

\item[{\sphinxstylestrong{iter}}] \leavevmode{[}int{]}
how many nonlinear iterations were needed for convergence

\item[{\sphinxstylestrong{liter}}] \leavevmode{[}int{]}
how many total linear iterations were needed for convergence

\item[{\sphinxstylestrong{converged}}] \leavevmode{[}bool{]}
whether or not the solver converged to a solution

\item[{\sphinxstylestrong{slow\_convergence}}] \leavevmode{[}bool{]}
whether or not the solver detected slow convergence

\item[{\sphinxstylestrong{projector\_setups}}] \leavevmode{[}int{]}
the number of times the linear projector was set up (e.g. Jacobian evaluation-factorization)

\item[{\sphinxstylestrong{rhs\_at\_converged}}] \leavevmode{[}np.ndarray{]}
the right-hand side of the ODE system at the converged solution

\end{description}

\end{description}\end{quote}
\index{converged (spitfire.time.nonlinear.SolverOutput attribute)@\spxentry{converged}\spxextra{spitfire.time.nonlinear.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput.converged}}\pysigline{\sphinxbfcode{\sphinxupquote{converged}}}~
\end{fulllineitems}

\index{iter (spitfire.time.nonlinear.SolverOutput attribute)@\spxentry{iter}\spxextra{spitfire.time.nonlinear.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput.iter}}\pysigline{\sphinxbfcode{\sphinxupquote{iter}}}~
\end{fulllineitems}

\index{liter (spitfire.time.nonlinear.SolverOutput attribute)@\spxentry{liter}\spxextra{spitfire.time.nonlinear.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput.liter}}\pysigline{\sphinxbfcode{\sphinxupquote{liter}}}~
\end{fulllineitems}

\index{projector\_setups (spitfire.time.nonlinear.SolverOutput attribute)@\spxentry{projector\_setups}\spxextra{spitfire.time.nonlinear.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput.projector_setups}}\pysigline{\sphinxbfcode{\sphinxupquote{projector\_setups}}}~
\end{fulllineitems}

\index{rhs\_at\_converged (spitfire.time.nonlinear.SolverOutput attribute)@\spxentry{rhs\_at\_converged}\spxextra{spitfire.time.nonlinear.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput.rhs_at_converged}}\pysigline{\sphinxbfcode{\sphinxupquote{rhs\_at\_converged}}}~
\end{fulllineitems}

\index{slow\_convergence (spitfire.time.nonlinear.SolverOutput attribute)@\spxentry{slow\_convergence}\spxextra{spitfire.time.nonlinear.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput.slow_convergence}}\pysigline{\sphinxbfcode{\sphinxupquote{slow\_convergence}}}~
\end{fulllineitems}

\index{solution (spitfire.time.nonlinear.SolverOutput attribute)@\spxentry{solution}\spxextra{spitfire.time.nonlinear.SolverOutput attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.SolverOutput.solution}}\pysigline{\sphinxbfcode{\sphinxupquote{solution}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{finite\_difference\_jacobian() (in module spitfire.time.nonlinear)@\spxentry{finite\_difference\_jacobian()}\spxextra{in module spitfire.time.nonlinear}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.nonlinear:spitfire.time.nonlinear.finite_difference_jacobian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{spitfire.time.nonlinear.}}\sphinxbfcode{\sphinxupquote{finite\_difference\_jacobian}}}{\emph{residual\_func}, \emph{residual\_value}, \emph{state}}{}
Compute a simple one-sided finite difference approximation to the Jacobian of a residual function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{residual\_func}} \textendash{} residual function of the state vector, r(q)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{residual\_value}} \textendash{} value of the residual function at the specified state vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} the state vector

\end{itemize}

\item[{Returns}] \leavevmode
a np.ndarray of the Jacobian matrix

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{spitfire.time.stepcontrol module}
\label{\detokenize{spitfire.time.stepcontrol:module-spitfire.time.stepcontrol}}\label{\detokenize{spitfire.time.stepcontrol:spitfire-time-stepcontrol-module}}\label{\detokenize{spitfire.time.stepcontrol::doc}}\index{spitfire.time.stepcontrol (module)@\spxentry{spitfire.time.stepcontrol}\spxextra{module}}
This module contains controllers for adaptive time stepping based on embedded temporal error estimation.
\index{CascadeController (class in spitfire.time.stepcontrol)@\spxentry{CascadeController}\spxextra{class in spitfire.time.stepcontrol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.CascadeController}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.stepcontrol.}}\sphinxbfcode{\sphinxupquote{CascadeController}}}{\emph{kp=0.06666666667}, \emph{ki=0.1333333333}, \emph{ratio\_kp=0.1}, \emph{ratio\_ki=0.3}, \emph{initial\_target\_error=1e-10}, \emph{target\_ratio=0.01}, \emph{max\_step=0.001}, \emph{max\_ramp=1.1}, \emph{first\_step=1e-06}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A two-level cascade control system on the embedded temporal error estimate and the ratio of two estimates.
\begin{quote}

The stepper method must support multiple embedded error estimates.
\end{quote}

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{kp}}] \leavevmode{[}float{]}
the modal gain of the proportional control mode for the error controller (default: 0.06666666667)

\item[{\sphinxstylestrong{ki}}] \leavevmode{[}float{]}
the modal gain of the integral control mode for the error controller (default: 0.1333333333)

\item[{\sphinxstylestrong{ratio\_kp}}] \leavevmode{[}float{]}
the modal gain of the proportional control mode for the ratio controller (default: 0.1)

\item[{\sphinxstylestrong{ratio\_ki}}] \leavevmode{[}float{]}
the modal gain of the integral control mode for the ratio controller (default: 0.3)

\item[{\sphinxstylestrong{target\_ratio}}] \leavevmode{[}float{]}
the value of the target ratio for the controller (default: 1.e-2)

\item[{\sphinxstylestrong{initial\_target\_error}}] \leavevmode{[}float{]}
the initial value of the target error for the controller (default: 1.e-10)

\item[{\sphinxstylestrong{max\_step}}] \leavevmode{[}float{]}
the maximum allowable time step (default: 1.e-3)

\item[{\sphinxstylestrong{max\_ramp}}] \leavevmode{[}float{]}
the maximum allowable rate of increase of the time step (default: 1.1)

\item[{\sphinxstylestrong{first\_step}}] \leavevmode{[}float{]}
the initial step size (default: 1.e-6)

\end{description}

\end{description}\end{quote}
\index{first\_step\_size() (spitfire.time.stepcontrol.CascadeController method)@\spxentry{first\_step\_size()}\spxextra{spitfire.time.stepcontrol.CascadeController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.CascadeController.first_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{first\_step\_size}}}{}{}
Obtain the initial step size

\end{fulllineitems}

\index{last\_step\_size() (spitfire.time.stepcontrol.CascadeController method)@\spxentry{last\_step\_size()}\spxextra{spitfire.time.stepcontrol.CascadeController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.CascadeController.last_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{last\_step\_size}}}{}{}
Obtain the most recent step size

\end{fulllineitems}

\index{step\_size\_is\_constant() (spitfire.time.stepcontrol.CascadeController method)@\spxentry{step\_size\_is\_constant()}\spxextra{spitfire.time.stepcontrol.CascadeController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.CascadeController.step_size_is_constant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step\_size\_is\_constant}}}{}{}
Whether or not this controller has a constant or variable step size

\end{fulllineitems}

\index{target\_error() (spitfire.time.stepcontrol.CascadeController method)@\spxentry{target\_error()}\spxextra{spitfire.time.stepcontrol.CascadeController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.CascadeController.target_error}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{target\_error}}}{}{}
Obtain the most target error, needed here just to avoid a base class

\end{fulllineitems}


\end{fulllineitems}

\index{ConstantTimeStep (class in spitfire.time.stepcontrol)@\spxentry{ConstantTimeStep}\spxextra{class in spitfire.time.stepcontrol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.ConstantTimeStep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.stepcontrol.}}\sphinxbfcode{\sphinxupquote{ConstantTimeStep}}}{\emph{step\_size}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A simple wrapper class for a constant time step.

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{step\_size}}] \leavevmode{[}float{]}
the size of the time step

\end{description}

\end{description}\end{quote}
\index{first\_step\_size() (spitfire.time.stepcontrol.ConstantTimeStep method)@\spxentry{first\_step\_size()}\spxextra{spitfire.time.stepcontrol.ConstantTimeStep method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.ConstantTimeStep.first_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{first\_step\_size}}}{}{}
Obtain the initial step size

\end{fulllineitems}

\index{last\_step\_size() (spitfire.time.stepcontrol.ConstantTimeStep method)@\spxentry{last\_step\_size()}\spxextra{spitfire.time.stepcontrol.ConstantTimeStep method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.ConstantTimeStep.last_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{last\_step\_size}}}{}{}
Obtain the most recent step size

\end{fulllineitems}

\index{step\_size\_is\_constant() (spitfire.time.stepcontrol.ConstantTimeStep method)@\spxentry{step\_size\_is\_constant()}\spxextra{spitfire.time.stepcontrol.ConstantTimeStep method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.ConstantTimeStep.step_size_is_constant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step\_size\_is\_constant}}}{}{}
Whether or not this controller has a constant or variable step size

\end{fulllineitems}

\index{target\_error() (spitfire.time.stepcontrol.ConstantTimeStep method)@\spxentry{target\_error()}\spxextra{spitfire.time.stepcontrol.ConstantTimeStep method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.ConstantTimeStep.target_error}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{target\_error}}}{}{}
Obtain the most target error, needed here just to avoid a base class

\end{fulllineitems}


\end{fulllineitems}

\index{PIController (class in spitfire.time.stepcontrol)@\spxentry{PIController}\spxextra{class in spitfire.time.stepcontrol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.PIController}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.stepcontrol.}}\sphinxbfcode{\sphinxupquote{PIController}}}{\emph{kp=0.06666666667}, \emph{ki=0.1333333333}, \emph{target\_error=1e-10}, \emph{max\_step=0.001}, \emph{max\_ramp=1.1}, \emph{first\_step=1e-06}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A PI controller on the embedded temporal error estimate

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{kp}}] \leavevmode{[}float{]}
the modal gain of the proportional control mode (default: 0.06666666667)

\item[{\sphinxstylestrong{ki}}] \leavevmode{[}float{]}
the modal gain of the integral control mode (default: 0.1333333333)

\item[{\sphinxstylestrong{target\_error}}] \leavevmode{[}float{]}
the target error for the controller (default: 1.e-10)

\item[{\sphinxstylestrong{max\_step}}] \leavevmode{[}float{]}
the maximum allowable time step (default: 1.e-3)

\item[{\sphinxstylestrong{max\_ramp}}] \leavevmode{[}float{]}
the maximum allowable rate of increase of the time step (default: 1.1)

\item[{\sphinxstylestrong{first\_step}}] \leavevmode{[}float{]}
the initial step size (default: 1.e-6)

\end{description}

\end{description}\end{quote}
\index{first\_step\_size() (spitfire.time.stepcontrol.PIController method)@\spxentry{first\_step\_size()}\spxextra{spitfire.time.stepcontrol.PIController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.PIController.first_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{first\_step\_size}}}{}{}
Obtain the initial step size

\end{fulllineitems}

\index{last\_step\_size() (spitfire.time.stepcontrol.PIController method)@\spxentry{last\_step\_size()}\spxextra{spitfire.time.stepcontrol.PIController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.PIController.last_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{last\_step\_size}}}{}{}
Obtain the most recent step size

\end{fulllineitems}

\index{step\_size\_is\_constant() (spitfire.time.stepcontrol.PIController method)@\spxentry{step\_size\_is\_constant()}\spxextra{spitfire.time.stepcontrol.PIController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.PIController.step_size_is_constant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step\_size\_is\_constant}}}{}{}
Whether or not this controller has a constant or variable step size

\end{fulllineitems}

\index{target\_error() (spitfire.time.stepcontrol.PIController method)@\spxentry{target\_error()}\spxextra{spitfire.time.stepcontrol.PIController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.PIController.target_error}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{target\_error}}}{}{}
Obtain the most target error, needed here just to avoid a base class

\end{fulllineitems}


\end{fulllineitems}

\index{RatioController (class in spitfire.time.stepcontrol)@\spxentry{RatioController}\spxextra{class in spitfire.time.stepcontrol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.RatioController}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{spitfire.time.stepcontrol.}}\sphinxbfcode{\sphinxupquote{RatioController}}}{\emph{kp=0.1}, \emph{ki=0.3}, \emph{target\_ratio=0.01}, \emph{max\_step=0.001}, \emph{max\_ramp=1.1}, \emph{first\_step=1e-06}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A PI controller on the ratio of two embedded temporal error estimates
\begin{quote}

The stepper method must support multiple embedded error estimates.
\end{quote}

\sphinxstylestrong{Constructor}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{kp}}] \leavevmode{[}float{]}
the modal gain of the proportional control mode (default: 0.1)

\item[{\sphinxstylestrong{ki}}] \leavevmode{[}float{]}
the modal gain of the integral control mode (default: 0.3)

\item[{\sphinxstylestrong{target\_ratio}}] \leavevmode{[}float{]}
the target error ratio for the controller (default: 1.e-2)

\item[{\sphinxstylestrong{max\_step}}] \leavevmode{[}float{]}
the maximum allowable time step (default: 1.e-3)

\item[{\sphinxstylestrong{max\_ramp}}] \leavevmode{[}float{]}
the maximum allowable rate of increase of the time step (default: 1.1)

\item[{\sphinxstylestrong{first\_step}}] \leavevmode{[}float{]}
the initial step size (default: 1.e-6)

\end{description}

\end{description}\end{quote}
\index{first\_step\_size() (spitfire.time.stepcontrol.RatioController method)@\spxentry{first\_step\_size()}\spxextra{spitfire.time.stepcontrol.RatioController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.RatioController.first_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{first\_step\_size}}}{}{}
Obtain the initial step size

\end{fulllineitems}

\index{last\_step\_size() (spitfire.time.stepcontrol.RatioController method)@\spxentry{last\_step\_size()}\spxextra{spitfire.time.stepcontrol.RatioController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.RatioController.last_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{last\_step\_size}}}{}{}
Obtain the most recent step size

\end{fulllineitems}

\index{step\_size\_is\_constant() (spitfire.time.stepcontrol.RatioController method)@\spxentry{step\_size\_is\_constant()}\spxextra{spitfire.time.stepcontrol.RatioController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.RatioController.step_size_is_constant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step\_size\_is\_constant}}}{}{}
Whether or not this controller has a constant or variable step size

\end{fulllineitems}

\index{target\_error() (spitfire.time.stepcontrol.RatioController method)@\spxentry{target\_error()}\spxextra{spitfire.time.stepcontrol.RatioController method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spitfire.time.stepcontrol:spitfire.time.stepcontrol.RatioController.target_error}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{target\_error}}}{}{}
Obtain the most target error, needed here just to avoid a base class

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{spitfire.time:module-spitfire.time}}\label{\detokenize{spitfire.time:module-contents}}\index{spitfire.time (module)@\spxentry{spitfire.time}\spxextra{module}}
This module contains Spitfire’s core time integration methods.


\subsection{Module contents}
\label{\detokenize{spitfire:module-spitfire}}\label{\detokenize{spitfire:module-contents}}\index{spitfire (module)@\spxentry{spitfire}\spxextra{module}}
This is the base spitfire module directory.


\chapter{Search the code}
\label{\detokenize{index:search-the-code}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{MJ2018}
\bibitem[MJ2018]{combustion:mj2018}
Michael A. Hansen, James C. Sutherland,
On the consistency of state vectors and Jacobian matrices,
Combustion and Flame,
Volume 193,
2018,
Pages 257-271,
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{s}
\item\relax\sphinxstyleindexentry{spitfire}\sphinxstyleindexpageref{spitfire:\detokenize{module-spitfire}}
\item\relax\sphinxstyleindexentry{spitfire.chemistry}\sphinxstyleindexpageref{spitfire.chemistry:\detokenize{module-spitfire.chemistry}}
\item\relax\sphinxstyleindexentry{spitfire.chemistry.flamelet}\sphinxstyleindexpageref{spitfire.chemistry.flamelet:\detokenize{module-spitfire.chemistry.flamelet}}
\item\relax\sphinxstyleindexentry{spitfire.chemistry.general\_diff\_rxn}\sphinxstyleindexpageref{spitfire.chemistry.general_diff_rxn:\detokenize{module-spitfire.chemistry.general_diff_rxn}}
\item\relax\sphinxstyleindexentry{spitfire.chemistry.mechanism}\sphinxstyleindexpageref{spitfire.chemistry.mechanism:\detokenize{module-spitfire.chemistry.mechanism}}
\item\relax\sphinxstyleindexentry{spitfire.chemistry.reactors}\sphinxstyleindexpageref{spitfire.chemistry.reactors:\detokenize{module-spitfire.chemistry.reactors}}
\item\relax\sphinxstyleindexentry{spitfire.time}\sphinxstyleindexpageref{spitfire.time:\detokenize{module-spitfire.time}}
\item\relax\sphinxstyleindexentry{spitfire.time.governor}\sphinxstyleindexpageref{spitfire.time.governor:\detokenize{module-spitfire.time.governor}}
\item\relax\sphinxstyleindexentry{spitfire.time.methods}\sphinxstyleindexpageref{spitfire.time.methods:\detokenize{module-spitfire.time.methods}}
\item\relax\sphinxstyleindexentry{spitfire.time.nonlinear}\sphinxstyleindexpageref{spitfire.time.nonlinear:\detokenize{module-spitfire.time.nonlinear}}
\item\relax\sphinxstyleindexentry{spitfire.time.stepcontrol}\sphinxstyleindexpageref{spitfire.time.stepcontrol:\detokenize{module-spitfire.time.stepcontrol}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}